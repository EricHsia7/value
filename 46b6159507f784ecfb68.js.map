{"version":3,"file":"46b6159507f784ecfb68.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,QAAS,GAAIH,GACM,iBAAZC,QACdA,QAAe,MAAID,IAEnBD,EAAY,MAAIC,GACjB,CATD,CASGK,KAAM,I,uBCTLC,E,kWCAJ,IAAMC,EAAcC,EAAQ,KAExBC,EAAU,CACZC,cAAc,EACdC,gBAAgB,EAChBC,eAAe,EACfC,YAAY,GAGRC,EAAS,CAAC,eAAgB,iBAAkB,gBAAiB,cA6B5D,SAAeC,EAASC,EAAAC,GAAA,OAAAC,EAAAC,MAAC,KAADC,UAAA,CAc9B,SAAAF,IAAA,OAAAA,EAAAG,EAdM,UAAyBC,EAAeC,GAC7C,IACE,IAAMC,EAAWV,EAAOQ,GAOxB,OAN0B,IAAtBb,EAAQe,KACVf,EAAQe,SAAkBjB,EAAYkB,eAAe,CACnDC,KAAMF,WAGcf,EAAQe,GAAUG,QAAQJ,EAEpD,CAAE,MAAOK,GAEP,OAAO,IACT,CACF,IAACT,MAAA,KAAAC,UAAA,CAkBM,SAAeS,EAAcC,GAAA,OAAAC,EAAAZ,MAAC,KAADC,UAAA,CAcnC,SAAAW,IAAA,OAAAA,EAAAV,EAdM,UAA8BC,GACnC,IACE,IAAME,EAAWV,EAAOQ,GAOxB,OAN0B,IAAtBb,EAAQe,KACVf,EAAQe,SAAkBjB,EAAYkB,eAAe,CACnDC,KAAMF,WAGSf,EAAQe,GAAUQ,MAEvC,CAAE,MAAOJ,GAEP,MAAO,EACT,CACF,IAACT,MAAA,KAAAC,UAAA,C,+yCCzED,IAAMa,EAEF,CAAC,EAWJ,SAAAC,IAAA,OAAAA,EAAAb,EATM,YACL,IACsBc,EADeC,EAAAC,QAAlBR,EAAe,IACZ,IAAtB,IAAAO,EAAAE,MAAAH,EAAAC,EAAAG,KAAAC,MAAwB,KAAbjB,EAAGY,EAAAM,MACNC,QAAyB3B,EAAU,EAAGQ,GAC5C,GAAImB,EAAkB,CACpB,IAAMC,EAAqBC,KAAKC,MAAMH,GACtCT,EAAUU,EAAmBG,IAAMH,CACrC,CACF,CAAC,OAAAf,GAAAQ,EAAAW,EAAAnB,EAAA,SAAAQ,EAAAY,GAAA,CACH,IAAC7B,MAAA,KAAAC,UAAA,C,+yCCXD,IAAM6B,EAEF,CAAC,EAWJ,SAAAC,IAAA,OAAAA,EAAA7B,EATM,YACL,IACsBc,EADeC,EAAAC,QAAlBR,EAAe,IACZ,IAAtB,IAAAO,EAAAE,MAAAH,EAAAC,EAAAG,KAAAC,MAAwB,KAAbjB,EAAGY,EAAAM,MACNU,QAAuBpC,EAAU,EAAGQ,GAC1C,GAAI4B,EAAgB,CAClB,IAAMC,EAAmBR,KAAKC,MAAMM,GACpCF,EAAQG,EAAiBN,IAAMM,CACjC,CACF,CAAC,OAAAxB,GAAAQ,EAAAW,EAAAnB,EAAA,SAAAQ,EAAAY,GAAA,CACH,IAAC7B,MAAA,KAAAC,UAAA,CC1BM,SAASiC,EAAsBC,GACpC,OAAOC,SAASC,cAAcF,EAChC,CAMO,SAASG,EAAqBC,EAAsBJ,GACzD,OAAOI,EAAQF,cAAcF,EAC/B,C,0TCRA,SAASK,EAAyBb,GAA4C,IAAhCc,EAAgBxC,UAAAyC,OAAA,QAAAC,IAAA1C,UAAA,IAAAA,UAAA,GAEtD2C,EAAe,IAAIC,gBAAgBC,OAAOC,SAASC,QAEzDJ,EAAaK,IAAI,IAAKtB,GAEtB,IAAMuB,EAASJ,OAAOC,SAASI,SAAW,IAAMP,EAAaQ,WACzDX,EAEFK,OAAOC,SAASM,QAAQH,GAExBI,QAAQC,aAAa,KAAM,GAAIL,EAEnC,CAU4B,SAAAM,IAa3B,OAb2BA,EAAAtD,EAA5B,YACE,IACE,IAAMuD,QAAiBC,MAAM,qBAAoB,IAAIC,MAAOC,YAAa,CACvEC,MAAO,aAET,IAAKJ,EAASK,GACZ,MAAM,IAAIC,MAAM,+BAElB,OAAON,EAASO,MAClB,CAAE,MAAOC,GAEP,OAAO,CACT,CACF,IAACjE,MAAA,KAAAC,UAAA,CA0CA,SAAAiE,IAAA,OAAAA,EAAAhE,EAjBM,YACL,IAAMiE,QAjDP,WAU2B,OAAAX,EAAAxD,MAAC,KAADC,UAAA,CAuCDmE,GACzB,MAA0B,kBAAfD,GACU,IAAfA,EACK,aAEA,eA5BJjC,EAAsB,kCAAkCmC,aAAa,aA+B7CF,EAAWG,MACtC9B,EAAyB2B,EAAWG,MAAM,GACnC,eAEP9B,EAAyB2B,EAAWG,MAAM,GACnC,KAGb,GAACJ,EAAAlE,MAAA,KAAAC,UAAA,CChFM,SAASsE,EAAgBjD,GAC9B,OAAc,IAAVA,EACK,OAEA,OAEX,CCJO,SAASkD,EAAYC,GAC1B,MAAgB,mBAA8CA,UAChE,CCeA,I,ECJYC,EDINC,EAAczC,EAAsB,MAEpC0C,EAA2C,CAAC,EAE9CC,EAA+B,GAC/BC,EAA+B,GAEnC,SAASC,IACP,IAAMC,EAAgB5C,SAAS6C,cAAc,OAC7CD,EAAcE,UAAUC,IAAI,KAE5B,IAAMC,EAAiBhD,SAAS6C,cAAc,OAC9CG,EAAeF,UAAUC,IAAI,KAC7BH,EAAcK,YAAYD,GAE1B,IAAME,EAAiBlD,SAAS6C,cAAc,OAC9CK,EAAeJ,UAAUC,IAAI,KAC7BH,EAAcK,YAAYC,GAE1B,IAAMC,EAAkBnD,SAAS6C,cAAc,OAK/C,OAJAM,EAAgBL,UAAUC,IAAI,KAC9BI,EAAgBC,UAAYhB,EAAY,eACxCQ,EAAcK,YAAYE,GAEnBP,CACT,CAEA,SAASS,IACP,SAASC,EAAUC,EAA6BC,EAAiBC,GAC/D,SAASC,EAAYH,EAA6BC,GAChDD,EAAeI,aAAa,SAAUH,EAAWjE,GACnD,CAEA,SAASqE,EAAWL,EAA6BC,GAC3BtD,EAAqBqD,EAAgB,MAC7CH,UAAYhB,EAAYoB,EAAWK,KACjD,CAEA,SAASC,EAAWP,EAA6BC,GAC3BtD,EAAqBqD,EAAgB,MAC7CQ,UAAYP,EAAWrF,IACrC,CAEA,SAAS6F,EAAYT,EAA6BC,GAC3BtD,EAAqBqD,EAAgB,MAC7CU,QAAUT,EAAWU,SAC9B,SAAUC,GACRA,EAAMC,iBACND,EAAME,kBAuIX,SAAkBC,GACvB,GAAI5B,EAAWpC,QAAU,EAAG,OAAO,EACnC,IAAMiE,EAAUC,EAAOF,GACvB,QAAgB/D,IAAZgE,EAAuB,OAAO,EAClC,IAAKA,EAAQL,SAAU,OAAO,EAG9B,GEjNK,SAAyBO,EAAmBC,GACjD,IAAK,IAAIC,EAAIF,EAAMnE,OAAS,EAAGqE,GAAK,EAAGA,IACjCF,EAAME,KAAOD,GACfD,EAAMG,OAAOD,EAAG,EAItB,CFwMEE,CAAgBnC,EAAY4B,UACrB9B,EAAY8B,GACf5B,EAAWpC,OAAS,EAAG,CACzB,IACMwE,EAAUN,EADE9B,EAAWA,EAAWpC,OAAS,SAEjCC,IAAZuE,IACFA,EAAQC,MAAO,EAEnB,CACA1B,GAEF,CAtJY2B,CAASxB,EAAWjE,GACtB,EACA,WAAa,EACjBgE,EAAeI,aAAa,WAAYxB,EAAgBqB,EAAWU,UACrE,CAEA,SAASe,EAAW1B,EAA6BC,GAC/CD,EAAeI,aAAa,OAAQxB,EAAgBqB,EAAWuB,MACjE,CAEA,SAASG,EAAc3B,EAA6BC,GAClDD,EAAeU,QAAU,WACvBkB,EAAQ3B,EAAWjE,GACrB,CACF,MAEoBgB,IAAhBkD,GACED,EAAWjE,KAAOkE,EAAYlE,IAChCmE,EAAYH,EAAgBC,GAE1BA,EAAWK,OAASJ,EAAYI,MAClCD,EAAWL,EAAgBC,GAEzBA,EAAWrF,OAASsF,EAAYtF,MAClC2F,EAAWP,EAAgBC,GAEzBA,EAAWU,WAAaT,EAAYS,UACtCF,EAAYT,EAAgBC,GAE1BA,EAAWuB,OAAStB,EAAYsB,MAClCE,EAAW1B,EAAgBC,GAEzBA,EAAW4B,OAAS3B,EAAY2B,MAClCF,EAAc3B,EAAgBC,KAGhCE,EAAYH,EAAgBC,GAC5BI,EAAWL,EAAgBC,GAC3BM,EAAWP,EAAgBC,GAC3BQ,EAAYT,EAAgBC,GAC5ByB,EAAW1B,EAAgBC,GAC3B0B,EAAc3B,EAAgBC,GAElC,CACA,IJpG4DzD,EIoGtDsF,EAAcC,MAAMC,MJpGkCxF,EIoGQ,KAAbwC,EJnGxCiD,iBAAiBzF,KIoG1B0F,EAAoBJ,EAAY/E,OAChCoF,EA0CD,WACL,IAAIC,EAAqB,GACzB,IAAK,IAAM3H,KAAOwE,EAAa,CAC7B,IAAM+B,EAAU/B,EAAYxE,GAC5B2H,EAAOC,KAAKrB,EACd,CAIA,OAHAoB,EAAOE,KAAK,SAAUC,EAAGC,GACvB,OAAOD,EAAEE,KAAOD,EAAEC,IACpB,GACOL,CACT,CApDmBM,GACXC,EAAiBR,EAASpF,OAC1B6F,EAAW,IAAIC,iBACrB,GAAIF,GAAkBT,EAAmB,CACvC,IAAK,IAAId,EAAIc,EAAmBd,EAAIuB,EAAgBvB,IAAK,CACvD,IAAM/B,EAAgBD,IACtBwD,EAASlD,YAAYL,GACrByC,EAAYO,KAAKhD,EACnB,CACAL,EAAY8D,OAAOF,EACrB,MACE,IAAK,IAAIG,EAAIb,EAAoB,EAAGa,GAAKJ,EAAgBI,IACvDjB,EAAYiB,GAAGC,SAInB,IAAK,IAAIC,EAAI,EAAGA,EAAIN,EAAgBM,IAAK,CACvC,IAAM/C,EAAchB,EAAiB+D,GAC/BhD,EAAakC,EAASc,GAE5BlD,EADuB+B,EAAYmB,GACThD,EAAYC,EACxC,CAEAhB,EAAmBiD,CACrB,CAEO,SAASe,EAAYrB,EAAmBjH,EAAmB0F,EAAmBK,EAA2BwC,GAC9G,IAAMpC,EG7ID,WACL,IAAMqC,EAAQ,CACZ,CAAC,GAAI,IACL,CAAC,GAAI,IACL,CAAC,GAAI,KAGHC,EAAgBC,KAAKC,MAAsB,UAAhBD,KAAKE,UAChCC,EAAgBH,KAAKC,MAAsB,UAAhBD,KAAKE,UAE9BpB,EAAS,IAAIsB,WAAW,IAC9BtB,EAAO,GAAK,GACZ,IAAK,IAAIhB,EAAI,GAAIA,EAAI,EAAGA,IAAK,CAC3B,IACMuC,EAAQP,EADJK,EAAgB,GAEpBG,EAAOD,EAAM,GAAMN,EAAgBM,EAAM,GAC/CvB,EAAOhB,GAAKwC,EACZP,KAAmB,EACnBI,KAAmB,CACrB,CAEA,OAAOI,OAAOC,aAAazJ,MAAM,KAAM+H,EACzC,CHuHgB2B,GACRC,EAAc,CAClBnC,KAAMA,EACNjH,KAAMA,EACN0F,KAAMA,EACNK,SAAUA,EACVa,MAAM,EACN2B,WAAYA,EACZV,MAAM,IAAIzE,MAAOC,UACjBjC,GAAI+E,GAGN,OADA9B,EAAY8B,GAASiD,EACdjD,CACT,CAcO,SAASE,EAAOF,GACrB,OAAO9B,EAAY8B,EACrB,CAEO,SAASa,EAAQb,GACtB,IAAMkD,EAAUhD,EAAOF,GACvB,QAAgB/D,IAAZiH,EAAuB,CAEzB,IAAMC,EAAmB/E,EAAWpC,OACpC,GAAImH,EAAmB,EAAG,CACxB,IAAMC,EAAYhF,EAAW+E,EAAmB,GAC1CjE,EAAagB,EAAOkD,QACPnH,IAAfiD,GACEA,EAAWjE,KAAOiI,EAAQjI,KAC5BiE,EAAWuB,MAAO,EAClByC,EAAQzC,MAAO,EACX2C,IAAcpD,GAChB5B,EAAWkD,KAAKtB,GAIxB,MAEEkD,EAAQzC,MAAO,EACfrC,EAAWkD,KAAKtB,GAKlB,OADAjB,KACO,CACT,CACA,OAAO,CACT,C,yHC1LA3C,OAAOxB,MAAQ,CACbyI,Y,EAAY,YACV,ID6MIC,EC7MEC,QJ+CH,WAA8B,OAAA/F,EAAAlE,MAAC,KAADC,UAAA,CI/CZiK,GACN,OAAXD,ID4MAD,EAAUnB,EAAY,OAAQ,OAAQ,QAAQ,EAAO,IACvCA,EAAY,WAAY,WAAY,YAAY,EAAO,IAC3EtB,EAAQyC,GACRvE,UNjNK,WAAkC,OAAA1E,EAAAf,MAAC,KAADC,UAAA,COI7BkK,SNFL,WAAgC,OAAApI,EAAA/B,MAAC,KAADC,UAAA,CMG3BmK,GAEV,EAPU1F,E,4KAOT,WAPS,OAAAA,EAAA1E,MAAA,KAAAC,UAAA,GAQVoK,mBAAoB,WAAa,GAGnC,QAAevH,OAAY,K,GGzBvBwH,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqB7H,IAAjB8H,EACH,OAAOA,EAAa3L,QAGrB,IAAIC,EAASuL,EAAyBE,GAAY,CAGjD1L,QAAS,CAAC,GAOX,OAHA4L,EAAoBF,GAAUzL,EAAQA,EAAOD,QAASyL,GAG/CxL,EAAOD,OACf,CAGAyL,EAAoBI,EAAID,EZzBpBvL,EAAW,GACfoL,EAAoBK,EAAI,CAAC7C,EAAQ8C,EAAUC,EAAIC,KAC9C,IAAGF,EAAH,CAMA,IAAIG,EAAeC,IACnB,IAASlE,EAAI,EAAGA,EAAI5H,EAASuD,OAAQqE,IAAK,CAGzC,IAFA,IAAK8D,EAAUC,EAAIC,GAAY5L,EAAS4H,GACpCmE,GAAY,EACPxC,EAAI,EAAGA,EAAImC,EAASnI,OAAQgG,MACpB,EAAXqC,GAAsBC,GAAgBD,IAAaI,OAAOtK,KAAK0J,EAAoBK,GAAGQ,MAAOhL,GAASmK,EAAoBK,EAAExK,GAAKyK,EAASnC,KAC9ImC,EAAS7D,OAAO0B,IAAK,IAErBwC,GAAY,EACTH,EAAWC,IAAcA,EAAeD,IAG7C,GAAGG,EAAW,CACb/L,EAAS6H,OAAOD,IAAK,GACrB,IAAIsE,EAAIP,SACEnI,IAAN0I,IAAiBtD,EAASsD,EAC/B,CACD,CACA,OAAOtD,CAnBP,CAJCgD,EAAWA,GAAY,EACvB,IAAI,IAAIhE,EAAI5H,EAASuD,OAAQqE,EAAI,GAAK5H,EAAS4H,EAAI,GAAG,GAAKgE,EAAUhE,IAAK5H,EAAS4H,GAAK5H,EAAS4H,EAAI,GACrG5H,EAAS4H,GAAK,CAAC8D,EAAUC,EAAIC,IaJ/BR,EAAoBe,EAAI,CAACxM,EAASyM,KACjC,IAAI,IAAInL,KAAOmL,EACXhB,EAAoBiB,EAAED,EAAYnL,KAASmK,EAAoBiB,EAAE1M,EAASsB,IAC5E+K,OAAOM,eAAe3M,EAASsB,EAAK,CAAEsL,YAAY,EAAMC,IAAKJ,EAAWnL,MCJ3EmK,EAAoBqB,EAAI,WACvB,GAA0B,iBAAfC,WAAyB,OAAOA,WAC3C,IACC,OAAOC,MAAQ,IAAIC,SAAS,cAAb,EAChB,CAAE,MAAOnK,GACR,GAAsB,iBAAXkB,OAAqB,OAAOA,MACxC,CACA,CAPuB,GCAxByH,EAAoBiB,EAAI,CAACQ,EAAKC,IAAUd,OAAOe,UAAUC,eAAeC,KAAKJ,EAAKC,G,MCKlF,IAAII,EAAkB,CACrB,IAAK,GAaN9B,EAAoBK,EAAElC,EAAK4D,GAA0C,IAA7BD,EAAgBC,GAGxD,IAAIC,EAAuB,CAACC,EAA4BC,KACvD,IAGIjC,EAAU8B,GAHTzB,EAAU6B,EAAaC,GAAWF,EAGhB1F,EAAI,EAC3B,GAAG8D,EAAS+B,KAAMjL,GAAgC,IAAxB0K,EAAgB1K,IAAa,CACtD,IAAI6I,KAAYkC,EACZnC,EAAoBiB,EAAEkB,EAAalC,KACrCD,EAAoBI,EAAEH,GAAYkC,EAAYlC,IAGhD,GAAGmC,EAAS,IAAI5E,EAAS4E,EAAQpC,EAClC,CAEA,IADGiC,GAA4BA,EAA2BC,GACrD1F,EAAI8D,EAASnI,OAAQqE,IACzBuF,EAAUzB,EAAS9D,GAChBwD,EAAoBiB,EAAEa,EAAiBC,IAAYD,EAAgBC,IACrED,EAAgBC,GAAS,KAE1BD,EAAgBC,GAAW,EAE5B,OAAO/B,EAAoBK,EAAE7C,IAG1B8E,EAAqB3N,KAAwB,kBAAIA,KAAwB,mBAAK,GAClF2N,EAAmBC,QAAQP,EAAqBQ,KAAK,KAAM,IAC3DF,EAAmB7E,KAAOuE,EAAqBQ,KAAK,KAAMF,EAAmB7E,KAAK+E,KAAKF,G,KC7CvF,IAAIG,EAAsBzC,EAAoBK,OAAEjI,EAAW,CAAC,KAAM,IAAO4H,EAAoB,M,UAC7FyC,EAAsBzC,EAAoBK,EAAEoC,I","sources":["webpack://value/webpack/universalModuleDefinition","webpack://value/webpack/runtime/chunk loaded","webpack://value/./src/lib/storage/index.ts","webpack://value/./src/lib/variable/index.ts","webpack://value/./src/lib/symbol/index.ts","webpack://value/./src/lib/selector/index.ts","webpack://value/./src/lib/version/index.ts","webpack://value/./src/lib/tools/boolean-to-string.ts","webpack://value/./src/interface/icons/index.ts","webpack://value/./src/interface/tabs/index.ts","webpack://value/./src/index.ts","webpack://value/./src/lib/tools/remove-from-array.ts","webpack://value/./src/lib/tools/generate-identifier.ts","webpack://value/webpack/bootstrap","webpack://value/webpack/runtime/define property getters","webpack://value/webpack/runtime/global","webpack://value/webpack/runtime/hasOwnProperty shorthand","webpack://value/webpack/runtime/jsonp chunk loading","webpack://value/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"value\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"value\"] = factory();\n\telse\n\t\troot[\"value\"] = factory();\n})(self, () => {\nreturn ","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","const localforage = require('localforage');\n\nlet storage = {\n  symbolsStore: false, // 0\n  variablesStore: false, // 1\n  settingsStore: false, // 2\n  cacheStore: false // 3\n};\n\nconst stores = ['symbolsStore', 'variablesStore', 'settingsStore', 'cacheStore'];\n\nasync function dropInstance(store: number): Promise<any> {\n  const storeKey = stores[store];\n  if (storage[storeKey] === false) {\n    storage[storeKey] = await localforage.createInstance({\n      name: storeKey\n    });\n  }\n  const operation = await storage[storeKey].dropInstance();\n  return operation;\n}\n\nexport async function lfSetItem(store: number, key: string, value: any): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].setItem(key, value);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    return null;\n  }\n}\n\nexport async function lfGetItem(store: number, key: string): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].getItem(key);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    return null;\n  }\n}\n\nexport async function lfRemoveItem(store: number, key: string): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].removeItem(key);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    return null;\n  }\n}\n\nexport async function lfListItemKeys(store: number): Promise<Array<string>> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const keys = await storage[storeKey].keys();\n    return keys;\n  } catch (err) {\n    console.error(err);\n    return [];\n  }\n}\n\nexport function getStoreKey(store: number): string {\n  return stores[store];\n}\n\nexport function getStoresLength(): number {\n  return stores.length;\n}\n\nexport async function isStoragePersistent(): Promise<boolean> {\n  // Check if site's storage has been marked as persistent\n  if (navigator.storage) {\n    if (navigator.storage.persist) {\n      const isPersisted = await navigator.storage.persisted();\n      return isPersisted;\n    }\n  }\n  return false;\n}\n\nexport async function askForPersistentStorage(): Promise<'granted' | 'denied' | 'unsupported'> {\n  // Request persistent storage for site\n  if (navigator.storage) {\n    if (navigator.storage.persist) {\n      const isPersisted = await navigator.storage.persist();\n      return isPersisted ? 'granted' : 'denied';\n    }\n  }\n  return 'unsupported';\n}\n","import { ModelComponent } from '../component/component';\nimport { lfGetItem, lfListItemKeys, lfRemoveItem, lfSetItem } from '../storage/index';\nimport { generateIdentifier } from '../tools/generate-identifier';\n\nexport interface Variable {\n  type: 'variable';\n  name: string;\n  template: ModelComponent<'template'> | undefined;\n  id: string;\n}\n\nconst Variables: {\n  [id: Variable['id']]: Variable;\n} = {};\n\nexport async function initializeVariables() {\n  const keys = await lfListItemKeys(1);\n  for (const key of keys) {\n    const thisVariableJSON = await lfGetItem(1, key);\n    if (thisVariableJSON) {\n      const thisVariableObject = JSON.parse(thisVariableJSON) as Symbol;\n      Variables[thisVariableObject.id] = thisVariableObject;\n    }\n  }\n}\n\nexport async function createVariable(): Promise<Variable['id']> {\n  const identifier = generateIdentifier();\n  const object: Variable = {\n    type: 'variable',\n    name: identifier,\n    template: undefined,\n    id: identifier\n  };\n\n  Variables[identifier] = object;\n\n  await lfSetItem(1, identifier, JSON.stringify(object));\n\n  return identifier;\n}\n\nexport function hasVariable(VariableID: Variable['id']): boolean {\n  return Variables.hasOwnProperty(VariableID);\n}\n\nexport function getVariable(VariableID: Variable['id']): Symbol | undefined {\n  if (hasVariable(VariableID)) {\n    return Variables[VariableID];\n  } else {\n    return undefined;\n  }\n}\n\nexport async function deleteVariable(VariableID: Variable['id']): Promise<boolean> {\n  if (hasVariable(VariableID)) {\n    delete Variables[VariableID];\n    await lfRemoveItem(1, VariableID);\n    return true;\n  } else {\n    return false;\n  }\n}\n","import { lfGetItem, lfListItemKeys, lfRemoveItem, lfSetItem } from '../storage/index';\nimport { generateIdentifier } from '../tools/generate-identifier';\nimport { deleteVariable, hasVariable, Variable } from '../variable/index';\n\nexport interface Symbol {\n  type: 'symbol';\n  name: string;\n  description: string;\n  variables: Array<Variable['id']>;\n  output: Variable['id'];\n  id: string;\n}\n\nconst Symbols: {\n  [id: Symbol['id']]: Symbol;\n} = {};\n\nexport async function initializeSymbols() {\n  const keys = await lfListItemKeys(0);\n  for (const key of keys) {\n    const thisSymbolJSON = await lfGetItem(0, key);\n    if (thisSymbolJSON) {\n      const thisSymbolObject = JSON.parse(thisSymbolJSON) as Symbol;\n      Symbols[thisSymbolObject.id] = thisSymbolObject;\n    }\n  }\n}\n\nexport async function createSymbol(name: Symbol['name'] = 'Unnamed Symbol'): Promise<Symbol['id']> {\n  const SymbolID = generateIdentifier();\n  const object: Symbol = {\n    type: 'symbol',\n    name: name,\n    description: '',\n    variables: [],\n    output: '',\n    id: SymbolID\n  };\n\n  Symbols[SymbolID] = object;\n\n  await lfSetItem(0, SymbolID, JSON.stringify(object));\n\n  return SymbolID;\n}\n\nexport function hasSymbol(SymbolID: Symbol['id']): boolean {\n  return Symbols.hasOwnProperty(SymbolID);\n}\n\nexport function getSymbol(SymbolID: Symbol['id']): Symbol | undefined {\n  if (hasSymbol(SymbolID)) {\n    return Symbols[SymbolID];\n  } else {\n    return undefined;\n  }\n}\n\nexport async function deleteSymbol(SymbolID: Symbol['id']): Promise<boolean> {\n  if (hasSymbol(SymbolID)) {\n    delete Symbols[SymbolID];\n    await lfRemoveItem(0, SymbolID);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport async function setSymbolName(SymbolID: Symbol['id'], name: Symbol['name']): Promise<boolean> {\n  if (!hasSymbol(SymbolID)) return false;\n  const thisSymbolObject = Symbols[SymbolID];\n  thisSymbolObject.name = name;\n  Symbols[SymbolID] = thisSymbolObject;\n  await lfSetItem(0, SymbolID, JSON.stringify(thisSymbolObject));\n  return true;\n}\n\nexport async function setSymbolDescription(SymbolID: Symbol['id'], description: Symbol['description']): Promise<boolean> {\n  if (!hasSymbol(SymbolID)) return false;\n  const thisSymbolObject = Symbols[SymbolID];\n  thisSymbolObject.description = description;\n  Symbols[SymbolID] = thisSymbolObject;\n  await lfSetItem(0, SymbolID, JSON.stringify(thisSymbolObject));\n  return true;\n}\n\nexport async function setSymbolOutput(SymbolID: Symbol['id'], output: Symbol['output']): Promise<boolean> {\n  if (!hasSymbol(SymbolID)) return false;\n  const thisSymbolObject = Symbols[SymbolID];\n  thisSymbolObject.output = output;\n  Symbols[SymbolID] = thisSymbolObject;\n  await lfSetItem(0, SymbolID, JSON.stringify(thisSymbolObject));\n  return true;\n}\n\nexport async function addVariableToSymbol(SymbolID: Symbol['id'], VariableID: Variable['id']): Promise<number> {\n  if (!hasSymbol(SymbolID)) return -1;\n  if (!hasVariable(VariableID)) return -1;\n  const thisSymbolObject = Symbols[SymbolID];\n  const existingIndex = thisSymbolObject.variables.indexOf(VariableID);\n  if (existingIndex === -1) {\n    thisSymbolObject.variables.push(VariableID);\n    Symbols[SymbolID] = thisSymbolObject;\n    await lfSetItem(0, SymbolID, JSON.stringify(thisSymbolObject));\n    return thisSymbolObject.variables.length - 1;\n  } else {\n    return existingIndex;\n  }\n}\n\nexport async function removeVariableFromSymbol(SymbolID: Symbol['id'], VariableID: Variable['id']): Promise<boolean> {\n  if (!hasSymbol(SymbolID)) return false;\n  if (!hasVariable(VariableID)) return false;\n  const thisSymbolObject = Symbols[SymbolID];\n  const existingIndex = thisSymbolObject.variables.indexOf(VariableID);\n  if (existingIndex === -1) {\n    return false;\n  } else {\n    thisSymbolObject.variables.splice(existingIndex, 1);\n    Symbols[SymbolID] = thisSymbolObject;\n    await lfSetItem(0, SymbolID, JSON.stringify(thisSymbolObject));\n    await deleteVariable(VariableID);\n    return true;\n  }\n}\n\nexport async function moveVariableInSymbol(SymbolID: Symbol['id'], VariableID: Variable['id'], offset: number): Promise<boolean> {\n  if (!hasSymbol(SymbolID)) return false;\n  if (!hasVariable(VariableID)) return false;\n  const thisSymbolObject = Symbols[SymbolID];\n  const existingIndex = thisSymbolObject.variables.indexOf(VariableID);\n  if (existingIndex === -1) {\n    return false;\n  } else {\n    thisSymbolObject.variables.splice(existingIndex, 1);\n    thisSymbolObject.variables.splice(existingIndex + offset, 0, VariableID);\n    Symbols[SymbolID] = thisSymbolObject;\n    await lfSetItem(0, SymbolID, JSON.stringify(thisSymbolObject));\n    return true;\n  }\n}\n","export function documentQuerySelector(selectorExpression: string): HTMLElement {\n  return document.querySelector(selectorExpression);\n}\n\nexport function documentQuerySelectorAll(selectorExpression: string): NodeListOf<HTMLElement> {\n  return document.querySelectorAll(selectorExpression);\n}\n\nexport function elementQuerySelector(element: HTMLElement, selectorExpression: string): HTMLElement {\n  return element.querySelector(selectorExpression);\n}\n\nexport function elementQuerySelectorAll(element: HTMLElement, selectorExpression: string): NodeListOf<HTMLElement> {\n  return element.querySelectorAll(selectorExpression);\n}\n\nexport function getElementsBelow(referenceElement: HTMLElement, className: string): Array<HTMLElement> {\n  const elements = [];\n  let sibling = referenceElement.nextElementSibling;\n\n  while (sibling) {\n    if (sibling.classList.contains(className)) {\n      elements.push(sibling);\n    }\n    sibling = sibling.nextElementSibling;\n  }\n\n  return elements;\n}","import { documentQuerySelector } from '../selector/index';\n\nfunction refreshPageWithTimeStamp(id: string, enforce: boolean = false): void {\n  // Get the URLSearchParams object from the current URL\n  const searchParams = new URLSearchParams(window.location.search);\n  // Set the 'timestamp' query parameter to the current timestamp\n  searchParams.set('v', id);\n  // Construct the new URL with updated query parameters\n  const newUrl = window.location.pathname + '?' + searchParams.toString();\n  if (enforce) {\n    // Redirect to the new URL\n    window.location.replace(newUrl);\n  } else {\n    history.replaceState(null, '', newUrl);\n  }\n}\n\ninterface AppVersion {\n  build: number;\n  hash: string;\n  full_hash: string;\n  branch_name: string; // branch name of the code base\n  timestamp: string; // timestamp in ISO fromat\n}\n\nasync function getAppVersion(): Promise<AppVersion | false> {\n  try {\n    const response = await fetch(`./version.json?_=${new Date().getTime()}`, {\n      cache: 'no-store'\n    });\n    if (!response.ok) {\n      throw new Error('Network response was not ok');\n    }\n    return response.json();\n  } catch (error) {\n    console.error('There was a problem with the fetch operation:', error);\n    return false;\n  }\n}\n\nexport function getHTMLVersionHash(): string {\n  return documentQuerySelector('head meta[name=\"version-hash\"]').getAttribute('content');\n}\n\nexport function getHTMLVersionFullHash(): string {\n  return documentQuerySelector('head meta[name=\"version-full-hash\"]').getAttribute('content');\n}\n\nexport function getHTMLVersionBranchName(): string {\n  return documentQuerySelector('head meta[name=\"version-branch-name\"]').getAttribute('content');\n}\n\nexport function getCommitURLOfCurrentVersion(): string {\n  const currentFullHash = getHTMLVersionFullHash();\n  return `https://github.com/EricHsia7/value/commit/${currentFullHash}`;\n}\n\nexport function getHTMLVersionTimeStamp(): string {\n  return documentQuerySelector('head meta[name=\"version-time-stamp\"]').getAttribute('content');\n}\n\ntype AppVersionStatus = 'fetchError' | 'unknownError' | 'refreshing' | 'ok';\n\nexport async function checkAppVersion(): Promise<AppVersionStatus> {\n  const appVersion = await getAppVersion();\n  if (typeof appVersion === 'boolean') {\n    if (appVersion === false) {\n      return 'fetchError';\n    } else {\n      return 'unknownError';\n    }\n  } else {\n    if (getHTMLVersionHash() !== appVersion.hash) {\n      refreshPageWithTimeStamp(appVersion.hash, true);\n      return 'refreshing';\n    } else {\n      refreshPageWithTimeStamp(appVersion.hash, false);\n      return 'ok';\n    }\n  }\n}\n","export function booleanToString(value: Boolean): 'true' | 'false' {\n  if (value === true) {\n    return 'true';\n  } else {\n    return 'false';\n  }\n}\n","import { MaterialSymbols } from './material-symbols-type';\n\nexport function getIconHTML(identifier: MaterialSymbols): string {\n  return /*html*/ `<span class=\"css_material_symbols_rounded\">${identifier}</span>`;\n}\n","import { documentQuerySelector, elementQuerySelector, elementQuerySelectorAll } from '../../lib/selector/index';\nimport { booleanToString } from '../../lib/tools/boolean-to-string';\nimport { generateIdentifier } from '../../lib/tools/generate-identifier';\nimport { removeFromArray } from '../../lib/tools/remove-from-array';\nimport { getIconHTML } from '../icons/index';\nimport { MaterialSymbols } from '../icons/material-symbols-type';\nimport { Page } from '../pages/index';\n\nexport interface Tab {\n  page: Page;\n  name: string;\n  icon: MaterialSymbols;\n  closable: boolean;\n  open: boolean;\n  parameters: Array<any>;\n  time: number;\n  id: string;\n}\n\nconst tabsElement = documentQuerySelector('.css_tabs');\n\nconst currentTabs: { [TabID: Tab['id']]: Tab } = {};\n\nlet previousTabsList: Array<Tab> = [];\nlet tabHistory: Array<Tab['id']> = [];\n\nfunction generateTabElement(): HTMLElement {\n  const newTabElement = document.createElement('div');\n  newTabElement.classList.add('css_tab');\n\n  const newIconElement = document.createElement('div');\n  newIconElement.classList.add('css_tab_icon');\n  newTabElement.appendChild(newIconElement);\n\n  const newNameElement = document.createElement('div');\n  newNameElement.classList.add('css_tab_name');\n  newTabElement.appendChild(newNameElement);\n\n  const newCloseElement = document.createElement('div');\n  newCloseElement.classList.add('css_tab_close');\n  newCloseElement.innerHTML = getIconHTML('close_small');\n  newTabElement.appendChild(newCloseElement);\n\n  return newTabElement;\n}\n\nfunction updateTabs(): void {\n  function updateTab(thisTabElement: HTMLElement, currentTab: Tab, previousTab: Tab | undefined): void {\n    function updateTabID(thisTabElement: HTMLElement, currentTab: Tab) {\n      thisTabElement.setAttribute('tab-id', currentTab.id);\n    }\n\n    function updateIcon(thisTabElement: HTMLElement, currentTab: Tab) {\n      const iconElement = elementQuerySelector(thisTabElement, '.css_tab_icon');\n      iconElement.innerHTML = getIconHTML(currentTab.icon);\n    }\n\n    function updateName(thisTabElement: HTMLElement, currentTab: Tab) {\n      const nameElement = elementQuerySelector(thisTabElement, '.css_tab_name');\n      nameElement.innerText = currentTab.name;\n    }\n\n    function updateClose(thisTabElement: HTMLElement, currentTab: Tab) {\n      const closeElement = elementQuerySelector(thisTabElement, '.css_tab_close');\n      closeElement.onclick = currentTab.closable\n        ? function (event) {\n            event.preventDefault();\n            event.stopPropagation();\n            closeTab(currentTab.id);\n          }\n        : function () {};\n      thisTabElement.setAttribute('closable', booleanToString(currentTab.closable));\n    }\n\n    function updateOpen(thisTabElement: HTMLElement, currentTab: Tab) {\n      thisTabElement.setAttribute('open', booleanToString(currentTab.open));\n    }\n\n    function updateOnclick(thisTabElement: HTMLElement, currentTab: Tab) {\n      thisTabElement.onclick = function () {\n        openTab(currentTab.id);\n      };\n    }\n\n    if (previousTab !== undefined) {\n      if (currentTab.id !== previousTab.id) {\n        updateTabID(thisTabElement, currentTab);\n      }\n      if (currentTab.icon !== previousTab.icon) {\n        updateIcon(thisTabElement, currentTab);\n      }\n      if (currentTab.name !== previousTab.name) {\n        updateName(thisTabElement, currentTab);\n      }\n      if (currentTab.closable !== previousTab.closable) {\n        updateClose(thisTabElement, currentTab);\n      }\n      if (currentTab.open !== previousTab.open) {\n        updateOpen(thisTabElement, currentTab);\n      }\n      if (currentTab.page !== previousTab.page) {\n        updateOnclick(thisTabElement, currentTab);\n      }\n    } else {\n      updateTabID(thisTabElement, currentTab);\n      updateIcon(thisTabElement, currentTab);\n      updateName(thisTabElement, currentTab);\n      updateClose(thisTabElement, currentTab);\n      updateOpen(thisTabElement, currentTab);\n      updateOnclick(thisTabElement, currentTab);\n    }\n  }\n  const tabElements = Array.from(elementQuerySelectorAll(tabsElement, '.css_tab'));\n  const tabElementsLength = tabElements.length;\n  const TabsList = listTabs();\n  const TabsListLength = TabsList.length;\n  const fragment = new DocumentFragment();\n  if (TabsListLength >= tabElementsLength) {\n    for (let i = tabElementsLength; i < TabsListLength; i++) {\n      const newTabElement = generateTabElement();\n      fragment.appendChild(newTabElement);\n      tabElements.push(newTabElement);\n    }\n    tabsElement.append(fragment);\n  } else {\n    for (let j = tabElementsLength - 1; j >= TabsListLength; j--) {\n      tabElements[j].remove();\n    }\n  }\n\n  for (let k = 0; k < TabsListLength; k++) {\n    const previousTab = previousTabsList[k];\n    const currentTab = TabsList[k];\n    const thisTabElement = tabElements[k];\n    updateTab(thisTabElement, currentTab, previousTab);\n  }\n\n  previousTabsList = TabsList;\n}\n\nexport function registerTab(page: Tab['page'], name: Tab['name'], icon: Tab['icon'], closable: Tab['closable'], parameters: Tab['parameters']): Tab['id'] {\n  const TabID = generateIdentifier();\n  const object: Tab = {\n    page: page,\n    name: name,\n    icon: icon,\n    closable: closable,\n    open: false,\n    parameters: parameters,\n    time: new Date().getTime(),\n    id: TabID\n  };\n  currentTabs[TabID] = object;\n  return TabID;\n}\n\nexport function listTabs(): Array<Tab> {\n  let result: Array<Tab> = [];\n  for (const key in currentTabs) {\n    const thisTab = currentTabs[key];\n    result.push(thisTab);\n  }\n  result.sort(function (a, b) {\n    return a.time - b.time;\n  });\n  return result;\n}\n\nexport function getTab(TabID: Tab['id']): Tab | undefined {\n  return currentTabs[TabID];\n}\n\nexport function openTab(TabID: Tab['id']): boolean {\n  const nextTab = getTab(TabID);\n  if (nextTab !== undefined) {\n    // hide the current\n    const tabHistoryLength = tabHistory.length;\n    if (tabHistoryLength > 0) {\n      const lastTabID = tabHistory[tabHistoryLength - 1];\n      const currentTab = getTab(lastTabID);\n      if (currentTab !== undefined) {\n        if (currentTab.id !== nextTab.id) {\n          currentTab.open = false;\n          nextTab.open = true;\n          if (lastTabID !== TabID) {\n            tabHistory.push(TabID);\n          }\n        }\n      }\n    } else {\n      // show the next\n      nextTab.open = true;\n      tabHistory.push(TabID);\n    }\n\n    // update tabs\n    updateTabs();\n    return true;\n  }\n  return false;\n}\n\nexport function closeTab(TabID: Tab['id']): boolean {\n  if (tabHistory.length <= 1) return false;\n  const thisTab = getTab(TabID);\n  if (thisTab === undefined) return false;\n  if (!thisTab.closable) return false;\n  removeFromArray(tabHistory, TabID);\n  delete currentTabs[TabID];\n  if (tabHistory.length > 0) {\n    const lastTabID = tabHistory[tabHistory.length - 1];\n    const lastTab = getTab(lastTabID);\n    if (lastTab !== undefined) {\n      lastTab.open = true;\n    }\n  }\n  updateTabs();\n  return true;\n}\n\nexport function initializeTabs(): void {\n  const homeTab = registerTab('home', 'Home', 'home', false, []);\n  const settingsTab = registerTab('settings', 'Settings', 'settings', false, []);\n  openTab(homeTab);\n  updateTabs();\n}\n","import { initializeSymbols } from './lib/symbol/index';\nimport { initializeVariables } from './lib/variable/index';\nimport { checkAppVersion } from './lib/version/index';\nimport { initializeTabs } from './interface/tabs/index';\n\nimport './interface/theme.css';\n\nimport './interface/index.css';\n\nimport './interface/icons/index.css';\n\nimport './interface/tabs/tabs.css';\nimport './interface/tabs/tab.css';\n\nwindow.value = {\n  initialize: async function () {\n    const status = await checkAppVersion();\n    if (status === 'ok') {\n      initializeTabs();\n      await initializeVariables();\n      await initializeSymbols();\n    }\n  },\n  secondlyInitialize: function () {}\n};\n\nexport default window.value;\n","export function removeFromArray(array: Array<any>, item: any): Array<any> {\n  for (let i = array.length - 1; i >= 0; i--) {\n    if (array[i] === item) {\n      array.splice(i, 1);\n    }\n  }\n  return array\n}\n","export function generateIdentifier(): string {\n  const chars = [\n    [48, 10], // 0-9: 48 - 57\n    [97, 26], // a-z: 97 - 122\n    [65, 26] // A-Z: 65 - 90\n  ];\n\n  let randomNumber1 = Math.floor(Math.random() * 0x10000000);\n  let randomNumber2 = Math.floor(Math.random() * 0x10000000);\n\n  const result = new Uint8Array(17);\n  result[0] = 95;\n  for (let i = 16; i > 0; i--) {\n    const n = randomNumber2 % 3;\n    const range = chars[n];\n    const code = range[0] + (randomNumber1 % range[1]);\n    result[i] = code;\n    randomNumber1 >>>= 1;\n    randomNumber2 >>>= 1;\n  }\n\n  return String.fromCharCode.apply(null, result);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t792: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkvalue\"] = self[\"webpackChunkvalue\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [790], () => (__webpack_require__(155)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["root","factory","exports","module","define","amd","self","deferred","localforage","require","storage","symbolsStore","variablesStore","settingsStore","cacheStore","stores","lfGetItem","_x5","_x6","_lfGetItem","apply","arguments","_asyncToGenerator","store","key","storeKey","createInstance","name","getItem","err","lfListItemKeys","_x9","_lfListItemKeys","keys","Variables","_initializeVariables","_step","_iterator","_createForOfIteratorHelper","s","n","done","value","thisVariableJSON","thisVariableObject","JSON","parse","id","e","f","Symbols","_initializeSymbols","thisSymbolJSON","thisSymbolObject","documentQuerySelector","selectorExpression","document","querySelector","elementQuerySelector","element","refreshPageWithTimeStamp","enforce","length","undefined","searchParams","URLSearchParams","window","location","search","set","newUrl","pathname","toString","replace","history","replaceState","_getAppVersion","response","fetch","Date","getTime","cache","ok","Error","json","error","_checkAppVersion","appVersion","getAppVersion","getAttribute","hash","booleanToString","getIconHTML","identifier","_initialize","tabsElement","currentTabs","previousTabsList","tabHistory","generateTabElement","newTabElement","createElement","classList","add","newIconElement","appendChild","newNameElement","newCloseElement","innerHTML","updateTabs","updateTab","thisTabElement","currentTab","previousTab","updateTabID","setAttribute","updateIcon","icon","updateName","innerText","updateClose","onclick","closable","event","preventDefault","stopPropagation","TabID","thisTab","getTab","array","item","i","splice","removeFromArray","lastTab","open","closeTab","updateOpen","updateOnclick","openTab","page","tabElements","Array","from","querySelectorAll","tabElementsLength","TabsList","result","push","sort","a","b","time","listTabs","TabsListLength","fragment","DocumentFragment","append","j","remove","k","registerTab","parameters","chars","randomNumber1","Math","floor","random","randomNumber2","Uint8Array","range","code","String","fromCharCode","generateIdentifier","object","nextTab","tabHistoryLength","lastTabID","initialize","homeTab","status","checkAppVersion","initializeVariables","initializeSymbols","secondlyInitialize","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","m","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","Object","every","r","d","definition","o","defineProperty","enumerable","get","g","globalThis","this","Function","obj","prop","prototype","hasOwnProperty","call","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","data","moreModules","runtime","some","chunkLoadingGlobal","forEach","bind","__webpack_exports__"],"sourceRoot":""}