{"version":3,"file":"4c473024ce5fcb300ebe.js","mappings":"8aAAA,IAAMA,EAAcC,EAAQ,KAExBC,EAAU,CACZC,cAAc,EACdC,gBAAgB,EAChBC,eAAe,EACfC,YAAY,GAGRC,EAAS,CAAC,eAAgB,iBAAkB,gBAAiB,cA6B5D,SAAeC,EAASC,EAAAC,GAAA,OAAAC,EAAAC,MAAC,KAADC,UAAA,CAc9B,SAAAF,IAAA,OAAAA,EAAAG,EAdM,UAAyBC,EAAeC,GAC7C,IACE,IAAMC,EAAWV,EAAOQ,GAOxB,OAN0B,IAAtBb,EAAQe,KACVf,EAAQe,SAAkBjB,EAAYkB,eAAe,CACnDC,KAAMF,WAGcf,EAAQe,GAAUG,QAAQJ,EAEpD,CAAE,MAAOK,GAEP,OAAO,IACT,CACF,IAACT,MAAA,KAAAC,UAAA,CAkBM,SAAeS,EAAcC,GAAA,OAAAC,EAAAZ,MAAC,KAADC,UAAA,CAcnC,SAAAW,IAAA,OAAAA,EAAAV,EAdM,UAA8BC,GACnC,IACE,IAAME,EAAWV,EAAOQ,GAOxB,OAN0B,IAAtBb,EAAQe,KACVf,EAAQe,SAAkBjB,EAAYkB,eAAe,CACnDC,KAAMF,WAGSf,EAAQe,GAAUQ,MAEvC,CAAE,MAAOJ,GAEP,MAAO,EACT,CACF,IAACT,MAAA,KAAAC,UAAA,C,+yCCzED,IAAMa,EAEF,CAAC,EAWJ,SAAAC,IAAA,OAAAA,EAAAb,EATM,YACL,IACsBc,EADeC,EAAAC,QAAlBR,EAAe,IACZ,IAAtB,IAAAO,EAAAE,MAAAH,EAAAC,EAAAG,KAAAC,MAAwB,KAAbjB,EAAGY,EAAAM,MACNC,QAAyB3B,EAAU,EAAGQ,GAC5C,GAAImB,EAAkB,CACpB,IAAMC,EAAqBC,KAAKC,MAAMH,GACtCT,EAAUU,EAAmBG,IAAMH,CACrC,CACF,CAAC,OAAAf,GAAAQ,EAAAW,EAAAnB,EAAA,SAAAQ,EAAAY,GAAA,CACH,IAAC7B,MAAA,KAAAC,UAAA,C,+yCCDD,IAAM6B,EAEF,CAAC,EAWJ,SAAAC,IAAA,OAAAA,EAAA7B,EATM,YACL,IACsBc,EADeC,EAAAC,QAAlBR,EAAe,IACZ,IAAtB,IAAAO,EAAAE,MAAAH,EAAAC,EAAAG,KAAAC,MAAwB,KAAbjB,EAAGY,EAAAM,MACNU,QAAuBpC,EAAU,EAAGQ,GAC1C,GAAI4B,EAAgB,CAClB,IAAMC,EAAmBR,KAAKC,MAAMM,GACpCF,EAAQG,EAAiBN,IAAMM,CACjC,CACF,CAAC,OAAAxB,GAAAQ,EAAAW,EAAAnB,EAAA,SAAAQ,EAAAY,GAAA,CACH,IAAC7B,MAAA,KAAAC,UAAA,CCpCM,SAASiC,EAAsBC,GACpC,OAAOC,SAASC,cAAcF,EAChC,CAMO,SAASG,EAAqBC,EAAsBJ,GACzD,OAAOI,EAAQF,cAAcF,EAC/B,CAEO,SAASK,EAAwBD,EAAsBJ,GAC5D,OAAOI,EAAQE,iBAAiBN,EAClC,C,0TCZA,SAASO,EAAyBf,GAA4C,IAAhCgB,EAAgB1C,UAAA2C,OAAA,QAAAC,IAAA5C,UAAA,IAAAA,UAAA,GAEtD6C,EAAe,IAAIC,gBAAgBC,OAAOC,SAASC,QAEzDJ,EAAaK,IAAI,IAAKxB,GAEtB,IAAMyB,EAASJ,OAAOC,SAASI,SAAW,IAAMP,EAAaQ,WACzDX,EAEFK,OAAOC,SAASM,QAAQH,GAExBI,QAAQC,aAAa,KAAM,GAAIL,EAEnC,CAU4B,SAAAM,IAa3B,OAb2BA,EAAAxD,EAA5B,YACE,IACE,IAAMyD,QAAiBC,MAAM,qBAAoB,IAAIC,MAAOC,YAAa,CACvEC,MAAO,aAET,IAAKJ,EAASK,GACZ,MAAM,IAAIC,MAAM,+BAElB,OAAON,EAASO,MAClB,CAAE,MAAOC,GAEP,OAAO,CACT,CACF,IAACnE,MAAA,KAAAC,UAAA,CA0CA,SAAAmE,IAAA,OAAAA,EAAAlE,EAjBM,YACL,IAAMmE,QAjDP,WAU2B,OAAAX,EAAA1D,MAAC,KAADC,UAAA,CAuCDqE,GACzB,MAA0B,kBAAfD,GACU,IAAfA,EACK,aAEA,eA5BJnC,EAAsB,kCAAkCqC,aAAa,aA+B7CF,EAAWG,MACtC9B,EAAyB2B,EAAWG,MAAM,GACnC,eAEP9B,EAAyB2B,EAAWG,MAAM,GACnC,KAGb,GAACJ,EAAApE,MAAA,KAAAC,UAAA,CChFM,SAASwE,EAAgBnD,GAC9B,OAAc,IAAVA,EACK,OAEA,OAEX,CCJO,SAASoD,EAAYC,GAC1B,MAAgB,mBAA8CA,UAChE,CCDA,IAAMC,EAAa1C,EAAsB,MCDlC,IAAM2C,EAAW3C,EAAsB,MACXI,EAAqBuC,EAAU,MCDlE,IAAMC,EAAa5C,EAAsB,MCAzC,IAAM6C,EAAe7C,EAAsB,MCWpC,IAAM8C,EAAuC,CAClDC,KHPK,WACLJ,EAASK,aAAa,YAAa,OAErC,EGKEhC,OFXK,WACL4B,EAAWI,aAAa,YAAa,OACvC,EEUEC,SDZK,WACLJ,EAAaG,aAAa,YAAa,OACzC,ECWEE,OJZK,SAAwBC,GAC7BT,EAAWM,aAAa,YAAa,OACvC,GIaaI,EAAuC,CAClDL,KHTK,WACLJ,EAASK,aAAa,YAAa,QACrC,EGQEhC,OFdK,WACL4B,EAAWI,aAAa,YAAa,QACvC,EEaEC,SDfK,WACLJ,EAAaG,aAAa,YAAa,QACzC,ECcEE,OJfK,WACLR,EAAWM,aAAa,YAAa,QACvC,GIgBaK,EAA2D,CACtEN,KAAM,CACJ,CACE7E,IAAK,mBACLG,KAAM,aACNiF,KAAM,MACNC,OAAQ,WACNC,QAAQC,IAAI,aACd,GAEF,CACEvF,IAAK,eACLG,KAAM,SACNiF,KAAM,SACNC,OAAQ,WAENG,GADcC,GAAY,SAAU,SAAU,UAAU,GAAO,EAAM,IAEvE,GAEF,CACEzF,IAAK,iBACLG,KAAM,WACNiF,KAAM,WACNC,OAAQ,WAENG,GADcC,GAAY,WAAY,WAAY,YAAY,GAAO,EAAM,IAE7E,IAGJ3C,OAAQ,GACRiC,SAAU,GACVC,OAAQ,IC7CJU,EAAoB5D,EAAsB,MAC1C6D,EAAqB7D,EAAsB,MAC3C8D,EAAc9D,EAAsB,MAEtC+D,EAA0C,GAE9C,SAASC,IACP,IAAMC,EAAqB/D,SAASgE,cAAc,OAClDD,EAAmBE,UAAUC,IAAI,KAEjC,IAAMC,EAAiBnE,SAASgE,cAAc,OAC9CG,EAAeF,UAAUC,IAAI,KAC7BH,EAAmBK,YAAYD,GAE/B,IAAME,EAAiBrE,SAASgE,cAAc,OAI9C,OAHAK,EAAeJ,UAAUC,IAAI,KAC7BH,EAAmBK,YAAYC,GAExBN,CACT,CAEO,SAASO,EAAkBC,GAChC,SAASC,EAAsBC,EAAkCC,EAAkCC,GACjG,SAASC,EAAWH,EAAkCC,GAChCxE,EAAqBuE,EAAqB,MAClDI,UAAYvC,EAAYoC,EAAgBtB,KACtD,CAEA,SAAS0B,EAAWL,EAAkCC,GAChCxE,EAAqBuE,EAAqB,MAClDM,UAAYL,EAAgBvG,IAC1C,CAEA,SAAS6G,EAAaP,EAAkCC,GACtDD,EAAoBQ,QAAU,SAAUC,GACtCA,EAAMC,kBACNT,EAAgBrB,SAChB+B,GACF,CACF,MAEyB3E,IAArBkE,EACED,EAAgB1G,MAAQ2G,EAAiB3G,MAC3C4G,EAAWH,EAAqBC,GAChCI,EAAWL,EAAqBC,GAChCM,EAAaP,EAAqBC,KAGpCE,EAAWH,EAAqBC,GAChCI,EAAWL,EAAqBC,GAChCM,EAAaP,EAAqBC,GAEtC,CAEA,IAAMW,EAAmBC,MAAMC,KAAKnF,EAAwBwD,EAAa,OACnE4B,EAAyBH,EAAiB7E,OAC1CiF,EAAkBlB,EAAU/D,OAClC,GAAIiF,GAAmBD,EAAwB,CAE7C,IADA,IAAME,EAAW,IAAIC,iBACZC,EAAIJ,EAAwBI,EAAIH,EAAiBG,IAAK,CAC7D,IAAM7B,EAAqBD,IAC3B4B,EAAStB,YAAYL,GACrBsB,EAAiBQ,KAAK9B,EACxB,CACAH,EAAYkC,OAAOJ,EACrB,MACE,IAAK,IAAIK,EAAIP,EAAyB,EAAGO,GAAKN,EAAiBM,IAC7DV,EAAiBU,GAAGC,SAIxB,IAAK,IAAIC,EAAI,EAAGA,EAAIR,EAAiBQ,IAAK,CACxC,IAAMtB,EAAmBd,EAAkBoC,GACrCvB,EAAkBH,EAAU0B,GAElCzB,EAD4Ba,EAAiBY,GACFvB,EAAiBC,EAC9D,CAEAjB,EAAkBuB,QAAU,WAa5BrB,EAAYd,aAAa,YAAa,QACtCa,EAAmBb,aAAa,YAAa,OAZ7C,EAEAa,EAAmBsB,QAAU,SAAUC,GACrCA,EAAMC,kBACNC,GACF,EAEAvB,EAAoBU,CACtB,CAOO,SAASa,IACdxB,EAAYd,aAAa,YAAa,SACtCa,EAAmBb,aAAa,YAAa,QAC/C,C,8tBC1FA,I,ECMYoD,EDNNC,EAAcrG,EAAsB,MAEpCsG,EAAoC,CAAC,EAEvCC,GAA+B,GAC/BC,GAA+B,GAEnC,SAASC,KACP,IAAMC,EAAgBxG,SAASgE,cAAc,OAC7CwC,EAAcvC,UAAUC,IAAI,KAE5B,IAAMC,EAAiBnE,SAASgE,cAAc,OAC9CG,EAAeF,UAAUC,IAAI,KAC7BsC,EAAcpC,YAAYD,GAE1B,IAAME,EAAiBrE,SAASgE,cAAc,OAC9CK,EAAeJ,UAAUC,IAAI,KAC7BsC,EAAcpC,YAAYC,GAE1B,IAAMoC,EAAkBzG,SAASgE,cAAc,OAK/C,OAJAyC,EAAgBxC,UAAUC,IAAI,KAC9BuC,EAAgB5B,UAAYvC,EAAY,eACxCkE,EAAcpC,YAAYqC,GAEnBD,CACT,CAEA,SAASE,KACP,SAASC,EAAUC,EAA6BC,EAAiBC,GAC/D,SAASlC,EAAWgC,EAA6BC,GAC3B3G,EAAqB0G,EAAgB,MAC7C/B,UAAYvC,EAAYuE,EAAWzD,KACjD,CAEA,SAAS0B,EAAW8B,EAA6BC,GAC3B3G,EAAqB0G,EAAgB,MAC7C7B,UAAY8B,EAAW1I,IACrC,CAEA,SAAS4I,EAAYH,EAA6BC,GAC3B3G,EAAqB0G,EAAgB,MAC7C3B,QAAU4B,EAAWG,SAC9B,SAAU9B,GACRA,EAAMC,kBAgJX,SAAkB8B,GACvB,IAAMC,EAAmBZ,GAAW9F,OACpC,GAAI0G,GAAoB,EAAG,OAAO,EAElC,IAAMC,EAAUf,EAAKa,GACrB,IAAKE,EAAS,OAAO,EACrB,GAAKA,UAAAA,EAASH,SAAU,OAAO,EAE/B,IAAK,IAAIpB,EAAIsB,EAAmB,EAAGtB,GAAK,EAAGA,IACzC,GAAIU,GAAWV,KAAOqB,EAAO,CAC3BzD,GAAQ8C,GAAWV,IACnB,KACF,QAGKQ,EAAKa,GE/NP,SAAyBG,EAAmBC,GACjD,IAAK,IAAIzB,EAAIwB,EAAM5G,OAAS,EAAGoF,GAAK,EAAGA,IACjCwB,EAAMxB,KAAOyB,GACfD,EAAME,OAAO1B,EAAG,EAItB,CFyNE2B,CAAgBjB,GAAYW,GAE5BP,IAGF,CApKYc,CAASX,EAAWtH,GACtB,EACA,SAAU2F,GACRA,EAAMC,iBACR,EACJyB,EAAe9D,aAAa,WAAYT,EAAgBwE,EAAWG,UACrE,CAEA,SAASS,EAAWb,EAA6BC,GAC/CD,EAAe9D,aAAa,OAAQT,EAAgBwE,EAAWa,OAC/Dd,EAAe3B,QAAU,WACvBzB,GAAQqD,EAAWtH,GACrB,CACF,MAEoBkB,IAAhBqG,GACED,EAAWzD,OAAS0D,EAAY1D,MAClCwB,EAAWgC,EAAgBC,GAEzBA,EAAW1I,OAAS2I,EAAY3I,MAClC2G,EAAW8B,EAAgBC,GAEzBA,EAAWG,WAAaF,EAAYE,UAAYH,EAAWtH,KAAOuH,EAAYvH,IAChFwH,EAAYH,EAAgBC,GAE1BA,EAAWa,OAASZ,EAAYY,MAAQb,EAAWtH,KAAOuH,EAAYvH,IACxEkI,EAAWb,EAAgBC,KAG7BjC,EAAWgC,EAAgBC,GAC3B/B,EAAW8B,EAAgBC,GAC3BE,EAAYH,EAAgBC,GAC5BY,EAAWb,EAAgBC,GAE/B,CAEA,IAAMc,EAAcrC,MAAMC,KAAKnF,EAAwB+F,EAAa,OAC9DyB,EAAoBD,EAAYnH,OAChCqH,EAoDD,WACL,IAAMC,EAAqB,GAC3B,IAAK,IAAM9J,KAAOoI,EAAM,CACtB,IAAMe,EAAUf,EAAKpI,GAErB8J,EAAOjC,KAAK,CACVkC,KAAMZ,EAAQY,KACd5J,KAAMgJ,EAAQhJ,KACdiF,KAAM+D,EAAQ/D,KACd4E,SAAUb,EAAQa,SAClBhB,SAAUG,EAAQH,SAClBU,KAAMP,EAAQO,KACdO,WAAYd,EAAQc,WACpBC,KAAMf,EAAQe,KACd3I,GAAI4H,EAAQ5H,IAEhB,CAIA,OAHAuI,EAAOK,KAAK,SAAUC,EAAGC,GACvB,OAAOD,EAAEF,KAAOG,EAAEH,IACpB,GACOJ,CACT,CAzEmBQ,GACXC,EAAiBV,EAASrH,OAChC,GAAI+H,GAAkBX,EAAmB,CAEvC,IADA,IAAMlC,EAAW,IAAIC,iBACZC,EAAIgC,EAAmBhC,EAAI2C,EAAgB3C,IAAK,CACvD,IAAMY,EAAgBD,KACtBb,EAAStB,YAAYoC,GACrBmB,EAAY9B,KAAKW,EACnB,CACAL,EAAYL,OAAOJ,EACrB,MACE,IAAK,IAAIK,EAAI6B,EAAoB,EAAG7B,GAAKwC,EAAgBxC,IACvD4B,EAAY5B,GAAGC,SAInB,IAAK,IAAIC,EAAI,EAAGA,EAAIsC,EAAgBtC,IAAK,CACvC,IAAMa,EAAcT,GAAiBJ,GAC/BY,EAAagB,EAAS5B,GAE5BU,EADuBgB,EAAY1B,GACTY,EAAYC,EACxC,CAEAT,GAAmBwB,CACrB,CAEO,SAASpE,GAAYsE,EAAmB5J,EAAmBiF,EAAmB4E,EAA2BhB,EAA2BiB,GACzI,IAAKD,EACH,IAAK,IAAMhK,KAAOoI,EAAM,CAEtB,GADgBA,EAAKpI,GACT+J,OAASA,EACnB,OAAO/J,CAEX,CAGF,IAAMiJ,EG3ID,WACL,IAAMuB,EAAQ,CACZ,CAAC,GAAI,IACL,CAAC,GAAI,IACL,CAAC,GAAI,KAGHC,EAAgBC,KAAKC,MAAsB,UAAhBD,KAAKE,UAChCC,EAAgBH,KAAKC,MAAsB,UAAhBD,KAAKE,UAE9Bd,EAAS,IAAIgB,WAAW,IAC9BhB,EAAO,GAAK,GACZ,IAAK,IAAIlC,EAAI,GAAIA,EAAI,EAAGA,IAAK,CAC3B,IACMmD,EAAQP,EADJK,EAAgB,GAEpBG,EAAOD,EAAM,GAAMN,EAAgBM,EAAM,GAC/CjB,EAAOlC,GAAKoD,EACZP,KAAmB,EACnBI,KAAmB,CACrB,CAEA,OAAOI,OAAOC,aAAatL,MAAM,KAAMkK,EACzC,CHqHgBqB,GACRC,EAAc,CAClBrB,KAAMA,EACN5J,KAAMA,EACNiF,KAAMA,EACN4E,SAAUA,EACVhB,SAAUA,EACVU,MAAM,EACNO,WAAYA,EACZC,MAAM,IAAIzG,MAAOC,UACjBnC,GAAI0H,GAGN,OADAb,EAAKa,GAASmC,EACPnC,CACT,CAyBO,SAASzD,GAAQyD,GACtB,IAAMoC,EAAUjD,EAAKa,GACrB,GAAIoC,EAAS,CACX,IAAMnC,EAAmBZ,GAAW9F,OACpC,GAAI0G,EAAmB,EAAG,CACxB,IAAMoC,EAAYhD,GAAWY,EAAmB,GAC1CL,EAAaT,EAAKkD,GACpBzC,IACFA,EAAWa,MAAO,EAClB2B,EAAQ3B,MAAO,EACX4B,IAAcrC,GAAOX,GAAWT,KAAKoB,GACzC/D,EAAS2D,EAAWkB,QACpBnF,EAASyG,EAAQtB,MAAKnK,MAAtBgF,EAAQ2G,EAAkBF,EAAQpB,aAEtC,MACEoB,EAAQ3B,MAAO,EACfpB,GAAWT,KAAKoB,GAChBrE,EAASyG,EAAQtB,MAAKnK,MAAtBgF,EAAQ2G,EAAkBF,EAAQpB,aAQpC,OAJAvB,KAGApC,EAAkBnB,EAAiBkG,EAAQtB,QACpC,CACT,CACA,OAAO,CACT,C,0HCpLAnH,OAAO1B,MAAQ,CACbsK,Y,EAAY,YACV,IAAMC,QVmCH,WAA8B,OAAAzH,EAAApE,MAAC,KAADC,UAAA,CUnCZ6L,GACN,OAAXD,ID4MNjG,GADkBC,GAAY,OAAQ,OAAQ,QAAQ,GAAO,EAAO,WZzN/D,WAAkC,OAAA9E,EAAAf,MAAC,KAADC,UAAA,CagB7B8L,SZJL,WAAgC,OAAAhK,EAAA/B,MAAC,KAADC,UAAA,CYK3B+L,GAEV,EAPU1D,E,8KAOT,WAPS,OAAAA,EAAAtI,MAAA,KAAAC,UAAA,GAQVgM,mBAAoB,WAAa,GAGnC,SAAejJ,OAAY,K","sources":["webpack://value/./src/lib/storage/index.ts","webpack://value/./src/lib/variable/index.ts","webpack://value/./src/lib/symbol/index.ts","webpack://value/./src/lib/selector/index.ts","webpack://value/./src/lib/version/index.ts","webpack://value/./src/lib/tools/boolean-to-string.ts","webpack://value/./src/interface/icons/index.ts","webpack://value/./src/interface/pages/editor/index.ts","webpack://value/./src/interface/pages/home/index.ts","webpack://value/./src/interface/pages/search/index.ts","webpack://value/./src/interface/pages/settings/index.ts","webpack://value/./src/interface/pages/index.ts","webpack://value/./src/interface/tabs-bar/menu.ts","webpack://value/./src/interface/tabs-bar/tabs.ts","webpack://value/./src/index.ts","webpack://value/./src/lib/tools/remove-from-array.ts","webpack://value/./src/lib/tools/generate-identifier.ts"],"sourcesContent":["const localforage = require('localforage');\n\nlet storage = {\n  symbolsStore: false, // 0\n  variablesStore: false, // 1\n  settingsStore: false, // 2\n  cacheStore: false // 3\n};\n\nconst stores = ['symbolsStore', 'variablesStore', 'settingsStore', 'cacheStore'];\n\nasync function dropInstance(store: number): Promise<any> {\n  const storeKey = stores[store];\n  if (storage[storeKey] === false) {\n    storage[storeKey] = await localforage.createInstance({\n      name: storeKey\n    });\n  }\n  const operation = await storage[storeKey].dropInstance();\n  return operation;\n}\n\nexport async function lfSetItem(store: number, key: string, value: any): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].setItem(key, value);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    return null;\n  }\n}\n\nexport async function lfGetItem(store: number, key: string): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].getItem(key);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    return null;\n  }\n}\n\nexport async function lfRemoveItem(store: number, key: string): Promise<any> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const operation = await storage[storeKey].removeItem(key);\n    return operation;\n  } catch (err) {\n    console.error(err);\n    return null;\n  }\n}\n\nexport async function lfListItemKeys(store: number): Promise<Array<string>> {\n  try {\n    const storeKey = stores[store];\n    if (storage[storeKey] === false) {\n      storage[storeKey] = await localforage.createInstance({\n        name: storeKey\n      });\n    }\n    const keys = await storage[storeKey].keys();\n    return keys;\n  } catch (err) {\n    console.error(err);\n    return [];\n  }\n}\n\nexport function getStoreKey(store: number): string {\n  return stores[store];\n}\n\nexport function getStoresLength(): number {\n  return stores.length;\n}\n\nexport async function isStoragePersistent(): Promise<boolean> {\n  // Check if site's storage has been marked as persistent\n  if (navigator.storage) {\n    if (navigator.storage.persist) {\n      const isPersisted = await navigator.storage.persisted();\n      return isPersisted;\n    }\n  }\n  return false;\n}\n\nexport async function askForPersistentStorage(): Promise<'granted' | 'denied' | 'unsupported'> {\n  // Request persistent storage for site\n  if (navigator.storage) {\n    if (navigator.storage.persist) {\n      const isPersisted = await navigator.storage.persist();\n      return isPersisted ? 'granted' : 'denied';\n    }\n  }\n  return 'unsupported';\n}\n","import { ModelComponent } from '../component/component';\nimport { lfGetItem, lfListItemKeys, lfRemoveItem, lfSetItem } from '../storage/index';\nimport { generateIdentifier } from '../tools/generate-identifier';\n\nexport interface Variable {\n  type: 'variable';\n  name: string;\n  template: ModelComponent<'template'> | undefined;\n  id: string;\n}\n\nconst Variables: {\n  [id: Variable['id']]: Variable;\n} = {};\n\nexport async function initializeVariables() {\n  const keys = await lfListItemKeys(1);\n  for (const key of keys) {\n    const thisVariableJSON = await lfGetItem(1, key);\n    if (thisVariableJSON) {\n      const thisVariableObject = JSON.parse(thisVariableJSON) as Symbol;\n      Variables[thisVariableObject.id] = thisVariableObject;\n    }\n  }\n}\n\nexport async function createVariable(): Promise<Variable['id']> {\n  const identifier = generateIdentifier();\n  const object: Variable = {\n    type: 'variable',\n    name: identifier,\n    template: undefined,\n    id: identifier\n  };\n\n  Variables[identifier] = object;\n\n  await lfSetItem(1, identifier, JSON.stringify(object));\n\n  return identifier;\n}\n\nexport function hasVariable(VariableID: Variable['id']): boolean {\n  return Variables.hasOwnProperty(VariableID);\n}\n\nexport function getVariable(VariableID: Variable['id']): Variable | undefined {\n  if (hasVariable(VariableID)) {\n    return Variables[VariableID];\n  } else {\n    return undefined;\n  }\n}\n\nexport async function deleteVariable(VariableID: Variable['id']): Promise<boolean> {\n  if (hasVariable(VariableID)) {\n    delete Variables[VariableID];\n    await lfRemoveItem(1, VariableID);\n    return true;\n  } else {\n    return false;\n  }\n}\n","import { Component, stringifyComponent } from '../component/component';\nimport { evaluateComponent } from '../component/evaluate';\nimport { lfGetItem, lfListItemKeys, lfRemoveItem, lfSetItem } from '../storage/index';\nimport { generateIdentifier } from '../tools/generate-identifier';\nimport { deleteVariable, getVariable, hasVariable, Variable } from '../variable/index';\n\nexport interface Symbol {\n  type: 'symbol';\n  name: string;\n  description: string;\n  variables: Array<Variable['id']>;\n  output: Variable['id'];\n  id: string;\n}\n\nexport interface EvaluatedSymbol {\n  type: 'evaluated-symbol';\n  name: string;\n  description: string;\n  value: string;\n  id: string;\n}\n\nconst Symbols: {\n  [id: Symbol['id']]: Symbol;\n} = {};\n\nexport async function initializeSymbols() {\n  const keys = await lfListItemKeys(0);\n  for (const key of keys) {\n    const thisSymbolJSON = await lfGetItem(0, key);\n    if (thisSymbolJSON) {\n      const thisSymbolObject = JSON.parse(thisSymbolJSON) as Symbol;\n      Symbols[thisSymbolObject.id] = thisSymbolObject;\n    }\n  }\n}\n\nexport async function createSymbol(name: Symbol['name'] = 'Unnamed Symbol'): Promise<Symbol['id']> {\n  const SymbolID = generateIdentifier();\n  const object: Symbol = {\n    type: 'symbol',\n    name: name,\n    description: '',\n    variables: [],\n    output: '',\n    id: SymbolID\n  };\n\n  Symbols[SymbolID] = object;\n\n  await lfSetItem(0, SymbolID, JSON.stringify(object));\n\n  return SymbolID;\n}\n\nexport function hasSymbol(SymbolID: Symbol['id']): boolean {\n  return Symbols.hasOwnProperty(SymbolID);\n}\n\nexport function getSymbol(SymbolID: Symbol['id']): Symbol | undefined {\n  if (hasSymbol(SymbolID)) {\n    return Symbols[SymbolID];\n  } else {\n    return undefined;\n  }\n}\n\nexport async function deleteSymbol(SymbolID: Symbol['id']): Promise<boolean> {\n  if (hasSymbol(SymbolID)) {\n    delete Symbols[SymbolID];\n    await lfRemoveItem(0, SymbolID);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport async function setSymbolName(SymbolID: Symbol['id'], name: Symbol['name']): Promise<boolean> {\n  if (!hasSymbol(SymbolID)) return false;\n  const thisSymbolObject = Symbols[SymbolID];\n  thisSymbolObject.name = name;\n  Symbols[SymbolID] = thisSymbolObject;\n  await lfSetItem(0, SymbolID, JSON.stringify(thisSymbolObject));\n  return true;\n}\n\nexport async function setSymbolDescription(SymbolID: Symbol['id'], description: Symbol['description']): Promise<boolean> {\n  if (!hasSymbol(SymbolID)) return false;\n  const thisSymbolObject = Symbols[SymbolID];\n  thisSymbolObject.description = description;\n  Symbols[SymbolID] = thisSymbolObject;\n  await lfSetItem(0, SymbolID, JSON.stringify(thisSymbolObject));\n  return true;\n}\n\nexport async function setSymbolOutput(SymbolID: Symbol['id'], output: Symbol['output']): Promise<boolean> {\n  if (!hasSymbol(SymbolID)) return false;\n  const thisSymbolObject = Symbols[SymbolID];\n  thisSymbolObject.output = output;\n  Symbols[SymbolID] = thisSymbolObject;\n  await lfSetItem(0, SymbolID, JSON.stringify(thisSymbolObject));\n  return true;\n}\n\nexport async function addVariableToSymbol(SymbolID: Symbol['id'], VariableID: Variable['id']): Promise<number> {\n  if (!hasSymbol(SymbolID)) return -1;\n  if (!hasVariable(VariableID)) return -1;\n  const thisSymbolObject = Symbols[SymbolID];\n  const existingIndex = thisSymbolObject.variables.indexOf(VariableID);\n  if (existingIndex === -1) {\n    thisSymbolObject.variables.push(VariableID);\n    Symbols[SymbolID] = thisSymbolObject;\n    await lfSetItem(0, SymbolID, JSON.stringify(thisSymbolObject));\n    return thisSymbolObject.variables.length - 1;\n  } else {\n    return existingIndex;\n  }\n}\n\nexport async function removeVariableFromSymbol(SymbolID: Symbol['id'], VariableID: Variable['id']): Promise<boolean> {\n  if (!hasSymbol(SymbolID)) return false;\n  if (!hasVariable(VariableID)) return false;\n  const thisSymbolObject = Symbols[SymbolID];\n  const existingIndex = thisSymbolObject.variables.indexOf(VariableID);\n  if (existingIndex === -1) {\n    return false;\n  } else {\n    thisSymbolObject.variables.splice(existingIndex, 1);\n    Symbols[SymbolID] = thisSymbolObject;\n    await lfSetItem(0, SymbolID, JSON.stringify(thisSymbolObject));\n    await deleteVariable(VariableID);\n    return true;\n  }\n}\n\nexport async function moveVariableInSymbol(SymbolID: Symbol['id'], VariableID: Variable['id'], offset: number): Promise<boolean> {\n  if (!hasSymbol(SymbolID)) return false;\n  if (!hasVariable(VariableID)) return false;\n  const thisSymbolObject = Symbols[SymbolID];\n  const existingIndex = thisSymbolObject.variables.indexOf(VariableID);\n  if (existingIndex === -1) {\n    return false;\n  } else {\n    thisSymbolObject.variables.splice(existingIndex, 1);\n    thisSymbolObject.variables.splice(existingIndex + offset, 0, VariableID);\n    Symbols[SymbolID] = thisSymbolObject;\n    await lfSetItem(0, SymbolID, JSON.stringify(thisSymbolObject));\n    return true;\n  }\n}\n\nexport async function evaluateSymbol(thisSymbol: Symbol): EvaluatedSymbol {\n  const fallback: EvaluatedSymbol = {\n    type: 'evaluated-symbol',\n    name: thisSymbol.name,\n    description: thisSymbol.description,\n    value: 'undefined',\n    id: thisSymbol.id\n  };\n\n  const outputVariableID = thisSymbol.output;\n  const outputVariable = getVariable(outputVariableID);\n  if (outputVariable === undefined) return fallback;\n\n  const evaluatedVariables: { [VariableName: Variable['name']]: Component } = {};\n  const variableIDs = thisSymbol.variables;\n  for (const variableID of variableIDs) {\n    const thisVariable = getVariable(variableID);\n    if (thisVariable === undefined) continue;\n    if (thisVariable?.template === undefined) continue;\n    const evaluatedVariableValue = evaluateComponent(thisVariable.template, evaluatedVariables);\n    if (evaluatedVariableValue === undefined) continue;\n    evaluatedVariables[thisVariable.name] = evaluatedVariableValue;\n  }\n\n  if (!evaluatedVariables.hasOwnProperty(outputVariable.name)) return fallback;\n\n  return {\n    type: 'evaluated-symbol',\n    name: thisSymbol.name,\n    description: thisSymbol.description,\n    value: stringifyComponent(evaluatedVariables[outputVariable.name]),\n    id: thisSymbol.id\n  };\n}\n\nexport function listSymbols(): Array<Symbol> {\n  const result: Array<Symbol> = [];\n\n  for (const key in Symbols) {\n    const thisSymbol = Symbols[key];\n    result.push({\n      type: 'symbol',\n      name: thisSymbol.name,\n      description: thisSymbol.description,\n      variables: thisSymbol.variables,\n      output: thisSymbol.output,\n      id: thisSymbol.id\n    });\n  }\n\n  return result;\n}\n\nexport function listEvaluatedSymbols(): Array<EvaluatedSymbol> {\n  const result: Array<EvaluatedSymbol> = [];\n  for (const key in Symbols) {\n    const thisSymbol = Symbols[key];\n    result.push(evaluateSymbol(thisSymbol));\n  }\n\n  return result;\n}\n","export function documentQuerySelector(selectorExpression: string): HTMLElement {\n  return document.querySelector(selectorExpression);\n}\n\nexport function documentQuerySelectorAll(selectorExpression: string): NodeListOf<HTMLElement> {\n  return document.querySelectorAll(selectorExpression);\n}\n\nexport function elementQuerySelector(element: HTMLElement, selectorExpression: string): HTMLElement {\n  return element.querySelector(selectorExpression);\n}\n\nexport function elementQuerySelectorAll(element: HTMLElement, selectorExpression: string): NodeListOf<HTMLElement> {\n  return element.querySelectorAll(selectorExpression);\n}\n\nexport function getElementsBelow(referenceElement: HTMLElement, className: string): Array<HTMLElement> {\n  const elements = [];\n  let sibling = referenceElement.nextElementSibling;\n\n  while (sibling) {\n    if (sibling.classList.contains(className)) {\n      elements.push(sibling);\n    }\n    sibling = sibling.nextElementSibling;\n  }\n\n  return elements;\n}","import { documentQuerySelector } from '../selector/index';\n\nfunction refreshPageWithTimeStamp(id: string, enforce: boolean = false): void {\n  // Get the URLSearchParams object from the current URL\n  const searchParams = new URLSearchParams(window.location.search);\n  // Set the 'timestamp' query parameter to the current timestamp\n  searchParams.set('v', id);\n  // Construct the new URL with updated query parameters\n  const newUrl = window.location.pathname + '?' + searchParams.toString();\n  if (enforce) {\n    // Redirect to the new URL\n    window.location.replace(newUrl);\n  } else {\n    history.replaceState(null, '', newUrl);\n  }\n}\n\ninterface AppVersion {\n  build: number;\n  hash: string;\n  full_hash: string;\n  branch_name: string; // branch name of the code base\n  timestamp: string; // timestamp in ISO fromat\n}\n\nasync function getAppVersion(): Promise<AppVersion | false> {\n  try {\n    const response = await fetch(`./version.json?_=${new Date().getTime()}`, {\n      cache: 'no-store'\n    });\n    if (!response.ok) {\n      throw new Error('Network response was not ok');\n    }\n    return response.json();\n  } catch (error) {\n    console.error('There was a problem with the fetch operation:', error);\n    return false;\n  }\n}\n\nexport function getHTMLVersionHash(): string {\n  return documentQuerySelector('head meta[name=\"version-hash\"]').getAttribute('content');\n}\n\nexport function getHTMLVersionFullHash(): string {\n  return documentQuerySelector('head meta[name=\"version-full-hash\"]').getAttribute('content');\n}\n\nexport function getHTMLVersionBranchName(): string {\n  return documentQuerySelector('head meta[name=\"version-branch-name\"]').getAttribute('content');\n}\n\nexport function getCommitURLOfCurrentVersion(): string {\n  const currentFullHash = getHTMLVersionFullHash();\n  return `https://github.com/EricHsia7/value/commit/${currentFullHash}`;\n}\n\nexport function getHTMLVersionTimeStamp(): string {\n  return documentQuerySelector('head meta[name=\"version-time-stamp\"]').getAttribute('content');\n}\n\ntype AppVersionStatus = 'fetchError' | 'unknownError' | 'refreshing' | 'ok';\n\nexport async function checkAppVersion(): Promise<AppVersionStatus> {\n  const appVersion = await getAppVersion();\n  if (typeof appVersion === 'boolean') {\n    if (appVersion === false) {\n      return 'fetchError';\n    } else {\n      return 'unknownError';\n    }\n  } else {\n    if (getHTMLVersionHash() !== appVersion.hash) {\n      refreshPageWithTimeStamp(appVersion.hash, true);\n      return 'refreshing';\n    } else {\n      refreshPageWithTimeStamp(appVersion.hash, false);\n      return 'ok';\n    }\n  }\n}\n","export function booleanToString(value: Boolean): 'true' | 'false' {\n  if (value === true) {\n    return 'true';\n  } else {\n    return 'false';\n  }\n}\n","import { MaterialSymbols } from './material-symbols-type';\n\nexport function getIconHTML(identifier: MaterialSymbols): string {\n  return /*html*/ `<span class=\"css_material_symbols_rounded\">${identifier}</span>`;\n}\n","import { documentQuerySelector } from '../../../lib/selector/index';\nimport { Symbol } from '../../../lib/symbol/index';\n\nconst editorPage = documentQuerySelector('.css_editor_page');\n\nexport function showEditorPage(SymbolID: Symbol['id']): void {\n  editorPage.setAttribute('displayed', 'true');\n}\n\nexport function hideEditorPage(): void {\n  editorPage.setAttribute('displayed', 'false');\n}\n","import { documentQuerySelector, elementQuerySelector } from '../../../lib/selector/index';\n\nexport const HomePage = documentQuerySelector('.css_home_page');\nexport const HomePageBodyElement = elementQuerySelector(HomePage, '.css_home_page_body');\n\nfunction updateHomePage(): void {}\n\nexport function showHomePage(): void {\n  HomePage.setAttribute('displayed', 'true');\n  updateHomePage();\n}\n\nexport function hideHomePage(): void {\n  HomePage.setAttribute('displayed', 'false');\n}\n","import { documentQuerySelector } from '../../../lib/selector/index';\n\nconst searchPage = documentQuerySelector('.css_search_page');\n\nexport function showSearchPage(): void {\n  searchPage.setAttribute('displayed', 'true');\n}\n\nexport function hideSearchPage(): void {\n  searchPage.setAttribute('displayed', 'false');\n}\n","import { documentQuerySelector } from '../../../lib/selector/index';\n\nconst settingsPage = documentQuerySelector('.css_settings_page');\n\nexport function showSettingsPage(): void {\n  settingsPage.setAttribute('displayed', 'true');\n}\n\nexport function hideSettingsPage(): void {\n  settingsPage.setAttribute('displayed', 'false');\n}\n","import { TabsBarMenuItemArray } from '../tabs-bar/menu';\nimport { openTab, registerTab } from '../tabs-bar/tabs';\nimport { hideEditorPage, showEditorPage } from './editor/index';\nimport { hideHomePage, showHomePage } from './home/index';\nimport { hideSearchPage, showSearchPage } from './search/index';\nimport { hideSettingsPage, showSettingsPage } from './settings/index';\n\nexport type HomePage = 'home';\nexport type SearchPage = 'search';\nexport type SettingsPage = 'settings';\nexport type EditorPage = 'editor';\nexport type Page = HomePage | SearchPage | SettingsPage | EditorPage;\n\nexport const showPage: { [page: Page]: Function } = {\n  home: showHomePage,\n  search: showSearchPage,\n  settings: showSettingsPage,\n  editor: showEditorPage\n};\n\nexport const hidePage: { [page: Page]: Function } = {\n  home: hideHomePage,\n  search: hideSearchPage,\n  settings: hideSettingsPage,\n  editor: hideEditorPage\n};\n\nexport const tabsBarMenuItems: { [page: Page]: TabsBarMenuItemArray } = {\n  home: [\n    {\n      key: 'home--new-symbol',\n      name: 'New Symbol',\n      icon: 'add',\n      action: function () {\n        console.log('new symbol');\n      }\n    },\n    {\n      key: 'home--search',\n      name: 'Search',\n      icon: 'search',\n      action: function () {\n        const TabID = registerTab('search', 'Search', 'search', false, true, []);\n        openTab(TabID);\n      }\n    },\n    {\n      key: 'home--settings',\n      name: 'Settings',\n      icon: 'settings',\n      action: function () {\n        const TabID = registerTab('settings', 'Settings', 'settings', false, true, []);\n        openTab(TabID);\n      }\n    }\n  ],\n  search: [],\n  settings: [],\n  editor: []\n};\n","import { documentQuerySelector, elementQuerySelector, elementQuerySelectorAll } from '../../lib/selector/index';\nimport { getIconHTML } from '../icons/index';\nimport { MaterialSymbols } from '../icons/material-symbols-type';\n\nexport interface TabsBarMenuItem {\n  key: string;\n  icon: MaterialSymbols;\n  name: string;\n  action: Function;\n}\n\nexport type TabsBarMenuItemArray = Array<TabsBarMenuItem>;\n\nconst menuButtonElement = documentQuerySelector('.css_tabs_bar_menu_button');\nconst menuOverlayElement = documentQuerySelector('.css_tabs_bar_menu_overlay');\nconst menuElement = documentQuerySelector('.css_tabs_bar_menu');\n\nlet previousMenuItems: TabsBarMenuItemArray = [];\n\nfunction generateMenuItemElement(): HTMLElement {\n  const newMenuItemElement = document.createElement('div');\n  newMenuItemElement.classList.add('css_tabs_bar_menu_item');\n\n  const newIconElement = document.createElement('div');\n  newIconElement.classList.add('css_tabs_bar_menu_item_icon');\n  newMenuItemElement.appendChild(newIconElement);\n\n  const newNameElement = document.createElement('div');\n  newNameElement.classList.add('css_tabs_bar_menu_item_name');\n  newMenuItemElement.appendChild(newNameElement);\n\n  return newMenuItemElement;\n}\n\nexport function updateTabsBarMenu(menuItems: TabsBarMenuItemArray): void {\n  function updateTabsBarMenuItem(thisMenuItemElement: HTMLElement, currentMenuItem: TabsBarMenuItem, previousMenuItem: TabsBarMenuItem | undefined): void {\n    function updateIcon(thisMenuItemElement: HTMLElement, currentMenuItem: TabsBarMenuItem): void {\n      const iconElement = elementQuerySelector(thisMenuItemElement, '.css_tabs_bar_menu_item_icon');\n      iconElement.innerHTML = getIconHTML(currentMenuItem.icon);\n    }\n\n    function updateName(thisMenuItemElement: HTMLElement, currentMenuItem: TabsBarMenuItem): void {\n      const iconElement = elementQuerySelector(thisMenuItemElement, '.css_tabs_bar_menu_item_name');\n      iconElement.innerText = currentMenuItem.name;\n    }\n\n    function updateAction(thisMenuItemElement: HTMLElement, currentMenuItem: TabsBarMenuItem): void {\n      thisMenuItemElement.onclick = function (event) {\n        event.stopPropagation();\n        currentMenuItem.action();\n        closeTabsBarMenu();\n      };\n    }\n\n    if (previousMenuItem !== undefined) {\n      if (currentMenuItem.key !== previousMenuItem.key) {\n        updateIcon(thisMenuItemElement, currentMenuItem);\n        updateName(thisMenuItemElement, currentMenuItem);\n        updateAction(thisMenuItemElement, currentMenuItem);\n      }\n    } else {\n      updateIcon(thisMenuItemElement, currentMenuItem);\n      updateName(thisMenuItemElement, currentMenuItem);\n      updateAction(thisMenuItemElement, currentMenuItem);\n    }\n  }\n\n  const menuItemElements = Array.from(elementQuerySelectorAll(menuElement, '.css_tabs_bar_menu_item'));\n  const menuItemElementsLength = menuItemElements.length;\n  const menuItemsLength = menuItems.length;\n  if (menuItemsLength >= menuItemElementsLength) {\n    const fragment = new DocumentFragment();\n    for (let i = menuItemElementsLength; i < menuItemsLength; i++) {\n      const newMenuItemElement = generateMenuItemElement();\n      fragment.appendChild(newMenuItemElement);\n      menuItemElements.push(newMenuItemElement);\n    }\n    menuElement.append(fragment);\n  } else {\n    for (let j = menuItemElementsLength - 1; j >= menuItemsLength; j--) {\n      menuItemElements[j].remove();\n    }\n  }\n\n  for (let k = 0; k < menuItemsLength; k++) {\n    const previousMenuItem = previousMenuItems[k];\n    const currentMenuItem = menuItems[k];\n    const thisMenuItemElement = menuItemElements[k];\n    updateTabsBarMenuItem(thisMenuItemElement, currentMenuItem, previousMenuItem);\n  }\n\n  menuButtonElement.onclick = function () {\n    openTabsBarMenu();\n  };\n\n  menuOverlayElement.onclick = function (event) {\n    event.stopPropagation();\n    closeTabsBarMenu();\n  };\n\n  previousMenuItems = menuItems;\n}\n\nexport function openTabsBarMenu(): void {\n  menuElement.setAttribute('displayed', 'true');\n  menuOverlayElement.setAttribute('displayed', 'true');\n}\n\nexport function closeTabsBarMenu(): void {\n  menuElement.setAttribute('displayed', 'false');\n  menuOverlayElement.setAttribute('displayed', 'false');\n}\n","import { documentQuerySelector, elementQuerySelector, elementQuerySelectorAll } from '../../lib/selector/index';\nimport { booleanToString } from '../../lib/tools/boolean-to-string';\nimport { generateIdentifier } from '../../lib/tools/generate-identifier';\nimport { removeFromArray } from '../../lib/tools/remove-from-array';\nimport { getIconHTML } from '../icons/index';\nimport { MaterialSymbols } from '../icons/material-symbols-type';\nimport { hidePage, Page, showPage, tabsBarMenuItems } from '../pages/index';\nimport { updateTabsBarMenu } from './menu';\n\nexport interface Tab {\n  page: Page;\n  name: string;\n  icon: MaterialSymbols;\n  reusable: boolean;\n  closable: boolean;\n  open: boolean;\n  parameters: Array<any>;\n  time: number;\n  id: string;\n}\n\nconst tabsElement = documentQuerySelector('.css_tabs');\n\nconst Tabs: { [TabID: Tab['id']]: Tab } = {};\n\nlet previousTabsList: Array<Tab> = [];\nlet tabHistory: Array<Tab['id']> = [];\n\nfunction generateTabElement(): HTMLElement {\n  const newTabElement = document.createElement('div');\n  newTabElement.classList.add('css_tab');\n\n  const newIconElement = document.createElement('div');\n  newIconElement.classList.add('css_tab_icon');\n  newTabElement.appendChild(newIconElement);\n\n  const newNameElement = document.createElement('div');\n  newNameElement.classList.add('css_tab_name');\n  newTabElement.appendChild(newNameElement);\n\n  const newCloseElement = document.createElement('div');\n  newCloseElement.classList.add('css_tab_close');\n  newCloseElement.innerHTML = getIconHTML('close_small');\n  newTabElement.appendChild(newCloseElement);\n\n  return newTabElement;\n}\n\nfunction updateTabs(): void {\n  function updateTab(thisTabElement: HTMLElement, currentTab: Tab, previousTab: Tab | undefined): void {\n    function updateIcon(thisTabElement: HTMLElement, currentTab: Tab): void {\n      const iconElement = elementQuerySelector(thisTabElement, '.css_tab_icon');\n      iconElement.innerHTML = getIconHTML(currentTab.icon);\n    }\n\n    function updateName(thisTabElement: HTMLElement, currentTab: Tab): void {\n      const nameElement = elementQuerySelector(thisTabElement, '.css_tab_name');\n      nameElement.innerText = currentTab.name;\n    }\n\n    function updateClose(thisTabElement: HTMLElement, currentTab: Tab): void {\n      const closeElement = elementQuerySelector(thisTabElement, '.css_tab_close');\n      closeElement.onclick = currentTab.closable\n        ? function (event) {\n            event.stopPropagation();\n            closeTab(currentTab.id);\n          }\n        : function (event) {\n            event.stopPropagation();\n          };\n      thisTabElement.setAttribute('closable', booleanToString(currentTab.closable));\n    }\n\n    function updateOpen(thisTabElement: HTMLElement, currentTab: Tab): void {\n      thisTabElement.setAttribute('open', booleanToString(currentTab.open));\n      thisTabElement.onclick = function () {\n        openTab(currentTab.id);\n      };\n    }\n\n    if (previousTab !== undefined) {\n      if (currentTab.icon !== previousTab.icon) {\n        updateIcon(thisTabElement, currentTab);\n      }\n      if (currentTab.name !== previousTab.name) {\n        updateName(thisTabElement, currentTab);\n      }\n      if (currentTab.closable !== previousTab.closable || currentTab.id !== previousTab.id) {\n        updateClose(thisTabElement, currentTab);\n      }\n      if (currentTab.open !== previousTab.open || currentTab.id !== previousTab.id) {\n        updateOpen(thisTabElement, currentTab);\n      }\n    } else {\n      updateIcon(thisTabElement, currentTab);\n      updateName(thisTabElement, currentTab);\n      updateClose(thisTabElement, currentTab);\n      updateOpen(thisTabElement, currentTab);\n    }\n  }\n\n  const tabElements = Array.from(elementQuerySelectorAll(tabsElement, '.css_tab'));\n  const tabElementsLength = tabElements.length;\n  const TabsList = listTabs();\n  const TabsListLength = TabsList.length;\n  if (TabsListLength >= tabElementsLength) {\n    const fragment = new DocumentFragment();\n    for (let i = tabElementsLength; i < TabsListLength; i++) {\n      const newTabElement = generateTabElement();\n      fragment.appendChild(newTabElement);\n      tabElements.push(newTabElement);\n    }\n    tabsElement.append(fragment);\n  } else {\n    for (let j = tabElementsLength - 1; j >= TabsListLength; j--) {\n      tabElements[j].remove();\n    }\n  }\n\n  for (let k = 0; k < TabsListLength; k++) {\n    const previousTab = previousTabsList[k];\n    const currentTab = TabsList[k];\n    const thisTabElement = tabElements[k];\n    updateTab(thisTabElement, currentTab, previousTab);\n  }\n\n  previousTabsList = TabsList;\n}\n\nexport function registerTab(page: Tab['page'], name: Tab['name'], icon: Tab['icon'], reusable: Tab['reusable'], closable: Tab['closable'], parameters: Tab['parameters']): Tab['id'] {\n  if (!reusable) {\n    for (const key in Tabs) {\n      const thisTab = Tabs[key];\n      if (thisTab.page === page) {\n        return key;\n      }\n    }\n  }\n\n  const TabID = generateIdentifier();\n  const object: Tab = {\n    page: page,\n    name: name,\n    icon: icon,\n    reusable: reusable,\n    closable: closable,\n    open: false,\n    parameters: parameters,\n    time: new Date().getTime(),\n    id: TabID\n  };\n  Tabs[TabID] = object;\n  return TabID;\n}\n\nexport function listTabs(): Array<Tab> {\n  const result: Array<Tab> = [];\n  for (const key in Tabs) {\n    const thisTab = Tabs[key];\n    // clone the object to prevent previousTabsList from referencing mutated properties before UI updates\n    result.push({\n      page: thisTab.page,\n      name: thisTab.name,\n      icon: thisTab.icon,\n      reusable: thisTab.reusable,\n      closable: thisTab.closable,\n      open: thisTab.open,\n      parameters: thisTab.parameters,\n      time: thisTab.time,\n      id: thisTab.id\n    });\n  }\n  result.sort(function (a, b) {\n    return a.time - b.time;\n  });\n  return result;\n}\n\nexport function openTab(TabID: Tab['id']): boolean {\n  const nextTab = Tabs[TabID];\n  if (nextTab) {\n    const tabHistoryLength = tabHistory.length;\n    if (tabHistoryLength > 0) {\n      const lastTabID = tabHistory[tabHistoryLength - 1];\n      const currentTab = Tabs[lastTabID];\n      if (currentTab) {\n        currentTab.open = false;\n        nextTab.open = true;\n        if (lastTabID !== TabID) tabHistory.push(TabID);\n        hidePage[currentTab.page]();\n        showPage[nextTab.page](...nextTab.parameters);\n      }\n    } else {\n      nextTab.open = true;\n      tabHistory.push(TabID);\n      showPage[nextTab.page](...nextTab.parameters);\n    }\n\n    // update tabs\n    updateTabs();\n\n    // update menu button\n    updateTabsBarMenu(tabsBarMenuItems[nextTab.page]);\n    return true;\n  }\n  return false;\n}\n\nexport function closeTab(TabID: Tab['id']): boolean {\n  const tabHistoryLength = tabHistory.length;\n  if (tabHistoryLength <= 1) return false;\n\n  const thisTab = Tabs[TabID];\n  if (!thisTab) return false;\n  if (!thisTab?.closable) return false;\n\n  for (let i = tabHistoryLength - 1; i >= 0; i--) {\n    if (tabHistory[i] !== TabID) {\n      openTab(tabHistory[i]);\n      break;\n    }\n  }\n\n  delete Tabs[TabID];\n  removeFromArray(tabHistory, TabID);\n\n  updateTabs();\n\n  return true;\n}\n\nexport function initializeTabs(): void {\n  const homeTabID = registerTab('home', 'Home', 'home', false, false, []);\n  openTab(homeTabID);\n}\n","import { initializeSymbols } from './lib/symbol/index';\nimport { initializeVariables } from './lib/variable/index';\nimport { checkAppVersion } from './lib/version/index';\nimport { initializeTabs } from './interface/tabs-bar/tabs';\n\nimport './interface/theme.css';\n\nimport './interface/index.css';\n\nimport './interface/icons/index.css';\n\nimport './interface/tabs-bar/separator.css';\nimport './interface/tabs-bar/tabs.css';\nimport './interface/tabs-bar/tab.css';\nimport './interface/tabs-bar/menu.css';\n\nimport './interface/pages/home/page.css';\nimport './interface/pages/home/body.css';\nimport './interface/pages/home/symbols/index.css';\n\nimport './interface/pages/search/page.css';\n\nimport './interface/pages/settings/page.css';\n\nimport './interface/pages/editor/page.css';\n\nwindow.value = {\n  initialize: async function () {\n    const status = await checkAppVersion();\n    if (status === 'ok') {\n      initializeTabs();\n      await initializeVariables();\n      await initializeSymbols();\n    }\n  },\n  secondlyInitialize: function () {}\n};\n\nexport default window.value;\n","export function removeFromArray(array: Array<any>, item: any): Array<any> {\n  for (let i = array.length - 1; i >= 0; i--) {\n    if (array[i] === item) {\n      array.splice(i, 1);\n    }\n  }\n  return array\n}\n","export function generateIdentifier(): string {\n  const chars = [\n    [48, 10], // 0-9: 48 - 57\n    [97, 26], // a-z: 97 - 122\n    [65, 26] // A-Z: 65 - 90\n  ];\n\n  let randomNumber1 = Math.floor(Math.random() * 0x10000000);\n  let randomNumber2 = Math.floor(Math.random() * 0x10000000);\n\n  const result = new Uint8Array(17);\n  result[0] = 95;\n  for (let i = 16; i > 0; i--) {\n    const n = randomNumber2 % 3;\n    const range = chars[n];\n    const code = range[0] + (randomNumber1 % range[1]);\n    result[i] = code;\n    randomNumber1 >>>= 1;\n    randomNumber2 >>>= 1;\n  }\n\n  return String.fromCharCode.apply(null, result);\n}\n"],"names":["localforage","require","storage","symbolsStore","variablesStore","settingsStore","cacheStore","stores","lfGetItem","_x5","_x6","_lfGetItem","apply","arguments","_asyncToGenerator","store","key","storeKey","createInstance","name","getItem","err","lfListItemKeys","_x9","_lfListItemKeys","keys","Variables","_initializeVariables","_step","_iterator","_createForOfIteratorHelper","s","n","done","value","thisVariableJSON","thisVariableObject","JSON","parse","id","e","f","Symbols","_initializeSymbols","thisSymbolJSON","thisSymbolObject","documentQuerySelector","selectorExpression","document","querySelector","elementQuerySelector","element","elementQuerySelectorAll","querySelectorAll","refreshPageWithTimeStamp","enforce","length","undefined","searchParams","URLSearchParams","window","location","search","set","newUrl","pathname","toString","replace","history","replaceState","_getAppVersion","response","fetch","Date","getTime","cache","ok","Error","json","error","_checkAppVersion","appVersion","getAppVersion","getAttribute","hash","booleanToString","getIconHTML","identifier","editorPage","HomePage","searchPage","settingsPage","showPage","home","setAttribute","settings","editor","SymbolID","hidePage","tabsBarMenuItems","icon","action","console","log","openTab","registerTab","menuButtonElement","menuOverlayElement","menuElement","previousMenuItems","generateMenuItemElement","newMenuItemElement","createElement","classList","add","newIconElement","appendChild","newNameElement","updateTabsBarMenu","menuItems","updateTabsBarMenuItem","thisMenuItemElement","currentMenuItem","previousMenuItem","updateIcon","innerHTML","updateName","innerText","updateAction","onclick","event","stopPropagation","closeTabsBarMenu","menuItemElements","Array","from","menuItemElementsLength","menuItemsLength","fragment","DocumentFragment","i","push","append","j","remove","k","_initialize","tabsElement","Tabs","previousTabsList","tabHistory","generateTabElement","newTabElement","newCloseElement","updateTabs","updateTab","thisTabElement","currentTab","previousTab","updateClose","closable","TabID","tabHistoryLength","thisTab","array","item","splice","removeFromArray","closeTab","updateOpen","open","tabElements","tabElementsLength","TabsList","result","page","reusable","parameters","time","sort","a","b","listTabs","TabsListLength","chars","randomNumber1","Math","floor","random","randomNumber2","Uint8Array","range","code","String","fromCharCode","generateIdentifier","object","nextTab","lastTabID","_toConsumableArray","initialize","status","checkAppVersion","initializeVariables","initializeSymbols","secondlyInitialize"],"sourceRoot":""}